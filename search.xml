<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java自学的经典题型总结]]></title>
    <url>%2F2019%2F02%2F20%2FJava%2F</url>
    <content type="text"><![CDATA[Java自学的经典题型总结经典题型 1.Hello Word 2.嵌套循环问题 3.定义一个类求圆的面积和周长 4.计算两点间的距离 5.定义一个类并打印其姓名和年龄 6.构造与重载定义个人信息 7.十进制对二进制八进制十六进制的转换 8.随机生成问题 9.数组的使用 Hello Word 程序猿的第一个程序 12345public class HelloWord &#123; public static void main(String[] args) &#123; System.out.println("Hello Word!!"); &#125;&#125; 嵌套循环问题 生成一个九九乘法表 1234567891011121314package 循环for嵌套;public class ForFor &#123; public static void main(String[] arge) &#123; int sum = 0; for(int i = 1 ;i &lt;= 9 ;i++) &#123; for(int j = 1;j &lt;= i ;j++) &#123; sum = i * j; System.out.print(i + "*" + j + "=" + sum + "\t"); &#125; System.out.println(); &#125; &#125;&#125; 定义一个圆类Circle 定义一个圆类——Circle. 在类的内部提供一个属性：半径(r). 同时 提供 两个 方法 ： 计算 面积 (getArea()) 和 计算 周长(getPerimeter()) 。 通过两个方法计算圆的周长和面积并且对计算结果进行输出。 最后定义一个测试类对 Circle 类进行使用。 123456789101112131415161718192021222324252627282930313233343536373839package 编码题2;import java.util.Scanner;/** * 定义一个圆类——Circle. * 在类的内部提供一个属性：半径(r). * 同时 提供 两个 方法 ： 计算 面积 (getArea()) 和 计算 周长(getPerimeter()) 。 * 通过两个方法计算圆的周长和面积并且对计算结果进行输出。 * 最后定义一个测试类对 Circle 类进行使用。 * @author pc-mac * */public class Circle &#123; double r; public static void main(String[] args) &#123; Circle n1 = new Circle(); System.out.println("###请输入圆的半径###"); Scanner n = new Scanner(System.in); int rString = n.nextInt(); n1.getArea(rString); n1.getPerimeter(rString); &#125; public void getArea(double r) &#123; this.r = r; System.out.println("面积是：" + Math.PI*r*r); &#125; public void getPerimeter(double r) &#123; this.r = r; System.out.println("周长是：" + Math.PI*r*2); &#125;&#125; 计算两点之间的距离1234567891011121314151617181920212223242526272829package 方法的构造;public class TestConstructor &#123; public static void main(String[] args) &#123; point p = new point(3.0,4.0); point p2 = new point(6.0,8.0); point or = new point(0,0); System.out.println(p.getDistance(or)); System.out.println(p2.getDistance(or)); &#125;&#125;class point&#123; //构造函数 public point (double _x,double _y)&#123; x = _x; y = _y; &#125; //属性 double x,y; //方法 public double getDistance(point p) &#123; return(Math.sqrt((x-p.x)*(x-p.x)+(y-p.x)*(y-p.y))); &#125;&#125; 此方法要注意的是在public double getDistance(point p)的方法中，传入的是point对象的值，所以在定义的时候直接定义了三个p;p2;or目的是方便调用 定义一个类并打印其姓名和年龄 编写 Java 程序,用于显示人的姓名和年龄。 定义一个人类Person。 该类中应该有两个私有属性： 姓名 (name) 和年龄 (age) 。 定义构造方法用来初始化数据成员。 再定义显示(display()) 方法将姓名和年龄打印出来。 在 main 方法中创建人类的实例然后将信息显示。 12345678910111213141516171819202122232425262728293031package 编码题1;/** * 编写 Java 程序,用于显示人的姓名和年龄。 * 定义一个人类Person。 * 该类中应该有两个私有属性： 姓名 (name) 和年龄 (age) 。 * 定义构造方法用来初始化数据成员。 * 再定义显示(display()) 方法将姓名和年龄打印出来。 * 在 main 方法中创建人类的实例然后将信息显示。 * @author pc-mac * */public class Person &#123; private String name; private int age; public static void main(String[] args) &#123; Person n1 = new Person("零分",20); n1.disPlay(); &#125; public Person(String name,int age) &#123; this.name = name; this.age = age; &#125; public void disPlay() &#123; System.out.println(name); System.out.println(age); &#125;&#125; 构造与重载定义个人信息 构造方法与重载： 定义一个网络用户类，信息有用户 ID、用户密码、 email 地址。 在建立类的实例时把以上三个信息都作为构造函数的参数输入。 其中用户 ID 和用户密码时必须缺省时，email地址是用户 ID 加上字符串”@qq.com”。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package 编码题3;/** * 构造方法与重载： * 定义一个网络用户类，信息有用户 ID、用户密码、 email 地址。 * 在建立类的实例时把以上三个信息都作为构造函数的参数输入。 * 其中用户 ID 和用户密码时必须缺省时，email地址是用户 ID 加上字符串"@qq.com"。 * @author pc-mac * */public class User &#123; public static void main(String[] args) &#123;// NetUser n1 = new NetUser(1001,"123654");//不能这么写 NetUser n1 = new NetUser(); n1.id = 1001; n1.pwd = "123456"; NetUser n2 = new NetUser(1003, "654321", "952339610@qq.com"); NetUser n3 = new NetUser(1002, "654789"); n1.disPlay(); n3.disPlay(); System.out.printf("用户为：%d的密码是:%s,邮箱是:%s\n",n2.id,n2.pwd,n2.email); &#125;&#125;class People&#123; int id; String pwd;&#125;class NetUser extends People&#123; String email; public NetUser(int id,String pwd) &#123; this.id = id; this.pwd = pwd; this.email = id + "@qq.com"; &#125; public NetUser(int id,String pwd,String email) &#123; this.id = id; this.pwd = pwd; this.email = email; &#125; public NetUser() &#123; &#125; public void disPlay() &#123; System.out.println("用户名:" + id + "密码是:" + "邮箱是:" + email); &#125;&#125; 进制转换 十进制转换 转换成二进制 转换成八进制 转换成十六进制 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package 编码题4;import java.util.Scanner;/** * 十进制转换 * 转换成二进制 * 转换成八进制 * 转换成十六进制 * @author pc-mac * */public class TestSwap &#123; public static void main(String[] args) &#123; System.out.println("请输入一个数进行转换:"); Scanner nScanner = new Scanner(System.in); Swap nSwap = new Swap(); int x = nScanner.nextInt(); nSwap.two(x); nSwap.eight(x); nSwap.tensix(x); &#125;&#125;class Swap&#123; int n; public void two(int n) &#123; this.n = n; int k = 1,sum = 0,y; while (n != 0) &#123; y = n % 2; n = n / 2; sum += y*k; k *= 10; &#125; System.out.println(sum); &#125; public void eight(int n) &#123; this.n = n; int k = 1,sum = 0,y; while (n != 0) &#123; y = n % 8; n = n / 8; sum += y*k; k *= 10; &#125; System.out.println(sum); &#125; public void tensix(int n) &#123; this.n = n; int i = 0,k; int[] a = new int[10]; char count[] = &#123;'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'&#125;; while(n != 0)&#123; a[i++] = n % 16; n = n / 16; &#125; for (int j = a.length-1 ; j &gt;= 0 ; j--) &#123; k = a[j]; System.out.printf("%c",count[k]); &#125; &#125;&#125; 随机生成月份 随机生成月份和字母并且判断是不是原因字母 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Switch &#123; public static void main(String[] arge) &#123; int month = (int)(1+12*Math.random()); System.out.println(month); switch (month) &#123; case 1: System.out.println("一月份"); break; case 2: System.out.println("二月份"); break; case 3: System.out.println("三月份"); break; case 4: System.out.println("四月份"); break; case 5: System.out.println("五月份"); break; case 6: System.out.println("六月份"); break; default: System.out.println("不是一二三四五六月份"); break; &#125; System.out.println("*************"); char a = 'a'; int rand = (int) (25*Math.random()); char a1 = (char) (a + rand); System.out.print(a1 + ":"); switch (a1) &#123; case 'a': case 'e': case 'i': case 'o': case 'u': System.out.println("这是元音字母！"); break; default: System.out.println("这不是元音字母！"); break; &#125; &#125;&#125; 数组的使用 创建一个类包括ID 和 Name 利用数组建立三个对象 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package 数组的使用;public class Arrary &#123; public static void main(String[] args) &#123; int[] arr1 = new int[10]; String[] arr2 = new String[10]; for (int i = 0; i &lt; arr1.length; i++) &#123;//在这里 arr1.length == 10 arr1[i] = 10*i; &#125; for (int i = 0; i &lt; arr1.length; i++) &#123; System.out.println(arr1[i]); &#125; User[] arr3 = new User[10]; arr3[0] = new User(1001, "零分"); arr3[1] = new User(1002, "满分"); arr3[2] = new User(1003, "没分"); for (int i = 0; i &lt; arr3.length; i++) &#123; System.out.println(arr3[i].getName()); &#125; &#125;&#125;class User&#123; public User(int id,String name) &#123; this.id = id; this.name = name; &#125; private int id; private String name; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; &#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>自学</tag>
        <tag>心得</tag>
        <tag>总结</tag>
        <tag>经验</tag>
        <tag>期末</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构期末总结]]></title>
    <url>%2F2019%2F02%2F10%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9C%9F%E6%9C%AB%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[数据结构重点分析及期末总结 零分(网络ID)是某师范大学，计科专业的一名屌丝，针对数据结构一科目的期末算法编程考试总结了如下几个算法。 重点分析 简单题型 栈 队列 树 排序 简单题型往下翻…………… 栈12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;iostream&gt;using namespace std;const int stackmax=100;//c初始值分配量typedef char st;typedef struct&#123; char *base; char *top; int stacksize;&#125;stack;int initstack(stack &amp;s)&#123;//初始化 s.base=new st[stackmax];//为顺序栈动态分配d一个最大容量为stachkmax的数组空间 if (!s.base) &#123; return 0;//储存分配空间失败 &#125; s.top=s.base;//top初始为base，空栈 s.stacksize=stackmax;//置为栈的最大容量 return 1;&#125;int putstack(stack &amp;s,char e)&#123;//入栈 if(s.top-s.base==s.stacksize)&#123;//当相等时为满栈 cout&lt;&lt;"满栈"&lt;&lt;endl; return 0; &#125; *s.top=e;//元素e压入栈顶 s.top++;//栈顶指针+1 return 1;&#125;char gettop(stack s)&#123; if(s.top!=s.base) cout&lt;&lt;*(s.top-1);//取q栈顶指针 return 0;&#125;int outstack(stack &amp;s,int e)&#123; if (s.top==s.base) &#123; return 0; &#125; e=*--s.top;//将d栈顶元素给e向下移一位 return 1;&#125;void disp(stack s)&#123; long int i; for(i=0;i&lt;s.top-s.base;i++)&#123; cout&lt;&lt;s.base[i]; &#125; cout&lt;&lt;endl;&#125;int main()&#123; char e; stack s; initstack(s); putstack(s,'A'); putstack(s,'B'); putstack(s,'C'); putstack(s,'D'); cout&lt;&lt;"栈S为："; disp(s); cout&lt;&lt;"栈顶元素为："; e=gettop(s); cout&lt;&lt;e&lt;&lt;endl; outstack(s,e); cout&lt;&lt;"栈顶出栈后的S："; disp(s); return 0;&#125; 队列12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include&lt;iostream&gt;using namespace std;const int MAXQSIZE=6;typedef char QElemType;typedef struct&#123; QElemType *base; int front ; int rear; &#125; SqQueue;int InitQueue(SqQueue &amp;Q)&#123; Q.base= new QElemType[MAXQSIZE]; if(!Q.base) return 0; Q.front =Q.rear=0; return 1;&#125;int EnQueue( SqQueue &amp;Q,QElemType e)&#123; if((Q.rear+1)%MAXQSIZE==Q.front)//队满 &#123; cout&lt;&lt;"错误"&lt;&lt;endl; &#125; Q.base[Q.rear] =e;//新元素插入队尾 Q.rear=(Q.rear+1)%MAXQSIZE;//队尾指针向后移动一位 return 1;&#125;int lengt(SqQueue &amp;Q)//求队长度&#123; return (Q.rear-Q.front+MAXQSIZE)%MAXQSIZE;&#125;int deleteQ(SqQueue &amp;Q,QElemType &amp;e)&#123; if(Q.rear==Q.front)//队空 return 0; e=Q.base[Q.front];//保存对头元素 Q.front=(Q.front+1)%MAXQSIZE;//队头指针向后移动一位 return 1;&#125;int DisQ(SqQueue Q)&#123; int m,i; m=lengt(Q); if(m==0) cout&lt;&lt;"空队列"; if((Q.rear+1)%MAXQSIZE==Q.front) cout&lt;&lt;"队满"&lt;&lt;endl; for(i=Q.front; i%MAXQSIZE!=Q.rear;i++) cout&lt;&lt;Q.base[i]; cout&lt;&lt;endl; return 0;&#125;int main()&#123; SqQueue Q; QElemType e; InitQueue(Q); DisQ(Q); EnQueue(Q,'A'); EnQueue(Q,'B'); EnQueue(Q,'C'); EnQueue(Q,'D'); cout&lt;&lt;"长度="; cout&lt;&lt;lengt(Q); cout&lt;&lt;"队列为="; DisQ(Q); deleteQ(Q,e); cout&lt;&lt;"长度="; cout&lt;&lt;lengt(Q); cout&lt;&lt;"队列为="; DisQ(Q); EnQueue(Q,'E'); cout&lt;&lt;"长度="; cout&lt;&lt;lengt(Q); cout&lt;&lt;"队列为="; DisQ(Q); EnQueue(Q,'F'); cout&lt;&lt;"队列为="; DisQ(Q); return 0;&#125; 树123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include &lt;stdlib.h&gt;#include &lt;iostream&gt;using namespace std;typedef int InfoType;typedef int KeyType; //假定关键字类型为整数typedef struct node //结点类型&#123; KeyType key; //关键字项 InfoType otherinfo; //其它数据域，InfoType视应用情况而定，下面不处理它 struct node *lchild,*rchild; //左右孩子指针&#125;BSTNode;typedef BSTNode *BSTree; //BSTree是二叉排序树的类型//在二叉排序树T上查找关键字为key的结点，成功时返回该结点位置，否则返回NULLBSTNode *findbst(BSTree t,KeyType key)&#123; if(t==NULL||key==t-&gt;key) return t; if(key&lt;t-&gt;key) return findbst(t-&gt;lchild,key); else return findbst(t-&gt;rchild,key);&#125;void InsertBST(BSTree *T,int key)&#123; //插入一个值为key的节点到二叉排序树中 BSTNode *p,*q; if((*T)==NULL) &#123; //树为空树 (*T)=(BSTree)malloc(sizeof(BSTNode)); (*T)-&gt;key=key; (*T)-&gt;lchild=(*T)-&gt;rchild=NULL; &#125; else &#123; p=(*T); while(p) &#123; q=p; if(p-&gt;key&gt;key) p=q-&gt;lchild; else if(p-&gt;key&lt;key) p=q-&gt;rchild; else &#123; cout&lt;&lt;endl&lt;&lt;"该二叉排序树中含有关键字为"&lt;&lt;key&lt;&lt;"的节点!"&lt;&lt;endl; return; &#125; &#125; p=(BSTree)malloc(sizeof(BSTNode)); p-&gt;key=key; p-&gt;lchild=p-&gt;rchild=NULL; if(q-&gt;key&gt;key) q-&gt;lchild=p; else q-&gt;rchild=p; &#125;&#125;BSTree CreateBST(void)&#123; //输入一个结点序列，建立一棵二叉排序树，将根结点指针返回 BSTree T=NULL; //初始时T为空树 KeyType key; cin&gt;&gt;key; //读入一个关键字 while(key) &#123; //假设key=0是输入结束标志 InsertBST(&amp;T,key); //将key插入二叉排序树T cin&gt;&gt;key; //读入下一关键字 &#125; return T; //返回建立的二叉排序树的根指针&#125;void ListBinTree(BSTree T) //用广义表示二叉树&#123; if(T!=NULL) &#123; cout&lt;&lt;T-&gt;key; if(T-&gt;lchild!=NULL||T-&gt;rchild!=NULL) &#123; cout&lt;&lt;"("; ListBinTree(T-&gt;lchild); if(T-&gt;rchild!=NULL) cout&lt;&lt;","; ListBinTree(T-&gt;rchild); cout&lt;&lt;")"; &#125; &#125;&#125;int main()&#123; BSTNode *findbst(BSTree t,KeyType key); void InsertBST(BSTree *Tptr,KeyType key); BSTree CreateBST(); void ListBinTree(BSTree T); BSTree T; BSTNode *p; int key; cout&lt;&lt;"请输入关键字（输入0为结束标志）："&lt;&lt;endl; T=CreateBST(); ListBinTree(T); cout&lt;&lt;endl; cout&lt;&lt;"请输入欲查找关键字:"; cin&gt;&gt;key; p=findbst(T,key); if(p==NULL) cout&lt;&lt;"没有找到"&lt;&lt;key&lt;&lt;"！"&lt;&lt;endl; else cout&lt;&lt;"找到"&lt;&lt;key&lt;&lt;"！"&lt;&lt;endl; ListBinTree(p); cout&lt;&lt;endl; return 0;&#125; 冒泡排序12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;stdio.h&gt;#define MaxSize 20typedef int KeyType; //定义关键字类型typedef char InfoType[10];typedef struct //记录类型&#123; KeyType key; //关键字项 InfoType data; //其他数据项,类型为InfoType&#125; RecType; //排序的记录类型定义void InsertSort(RecType R[],int n) //对R[0..n-1]按递增有序进行直接插入排序&#123; int i,j,k; RecType tmp; for (i=1; i&lt;n; i++) &#123; tmp=R[i]; j=i-1; //从右向左在有序区R[0..i-1]中找R[i]的插入位置 while (j&gt;=0 &amp;&amp; tmp.key&lt;R[j].key) &#123; R[j+1]=R[j]; //将关键字大于R[i].key的记录后移 j--; &#125; R[j+1]=tmp; //在j+1处插入R[i] printf("i=%d: ",i); for (k=0; k&lt;n; k++) printf("%d ",R[k].key); printf("\n"); &#125;&#125;int main()&#123; int i,n=5; RecType R[MaxSize]; KeyType a[]= &#123;3,24,12,6,1&#125;; for (i=0; i&lt;n; i++) R[i].key=a[i]; printf("排序前:"); for (i=0; i&lt;n; i++) printf("%d ",R[i].key); printf("\n"); InsertSort(R,n); printf("排序后:"); for (i=0; i&lt;n; i++) printf("%d ",R[i].key); printf("\n"); return 0;&#125; 题型分类 插入 删除 合并 排序 折半查找递归算法 顺序表题型插入12345678910int listinsert_sq(sqlist &amp;l,int i,et e)&#123; if(i&lt;1||i&gt;l.length+1) return 0; for (int j=l.length-1; j&gt;=i-1; j--) &#123; l.elem[j+1]=l.elem[j]; &#125; l.elem[i-1]=e; ++l.length; return 1;&#125; 删除12345678910int listdelete_sq(sqlist &amp;l,int i,et &amp;e)&#123; if(i&lt;1||i&gt;l.length) return 0; e=l.elem[i-1]; for (int j=i; j&lt;=l.length-1; j++) &#123; l.elem[j-1]=l.elem[j]; &#125; --l.length; return 1;&#125; 完整程序12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include"iostream"using namespace std;#define maxsize 100typedef char et;typedef struct&#123; et *elem; int length;&#125;sqlist;int initlist_sq(sqlist &amp;l)&#123; l.elem=new et[maxsize]; if(!l.elem) return 0; l.length=0; return 1;&#125;int listinsert_sq(sqlist &amp;l,int i,et e)&#123; if(i&lt;1||i&gt;l.length+1) return 0; for (int j=l.length-1; j&gt;=i-1; j--) &#123; l.elem[j+1]=l.elem[j]; &#125; l.elem[i-1]=e; ++l.length; return 1;&#125;int listdelete_sq(sqlist &amp;l,int i,et &amp;e)&#123; if(i&lt;1||i&gt;l.length) return 0; e=l.elem[i-1]; for (int j=i; j&lt;=l.length-1; j++) &#123; l.elem[j-1]=l.elem[j]; &#125; --l.length; return 1;&#125;void disp_sq(sqlist l)&#123; if(l.length==0) cout&lt;&lt;"此顺序表为空"&lt;&lt;endl; for(int i=0;i&lt;l.length;i++)&#123; cout&lt;&lt;l.elem[i]; &#125; cout&lt;&lt;endl;&#125;int main()&#123; et e; sqlist l; initlist_sq(l); disp_sq(l); listinsert_sq(l,1,'A'); listinsert_sq(l,2,'B'); listinsert_sq(l,3,'C'); disp_sq(l); listdelete_sq(l,1,e); disp_sq(l); cout&lt;&lt;"删除的元素是："&lt;&lt;e&lt;&lt;endl;&#125; 链表题型插入1234567891011121314151617int listinsert(lk &amp;l,int i,et e)&#123; lk p; p=l; int j=0; while(p&amp;&amp;j&lt;i-1)&#123; p=p-&gt;next; j++; &#125; if (!p||j&gt;i-1) &#123; return 0; &#125; lk s=new ln; s-&gt;date=e;//将e的值赋值给s的值域 s-&gt;next=p-&gt;next;//新元素s的指针域指向旧元素p的指针域 p-&gt;next=s;//将p的指针域指向s元素 return 1;&#125; 删除123456789101112131415161718int listdelete(lk &amp;l,int i,et &amp;e)&#123; lk p; p=l; int j=0; while(p-&gt;next&amp;&amp;j&lt;i-1)&#123; p=p-&gt;next; j++; &#125; if (!(p-&gt;next)||j&gt;i-1) &#123; return 0; &#125; lk q; q=p-&gt;next;//q的指针指向p的指针域 p-&gt;next=q-&gt;next;//p的指针域指向q的指针域 e=q-&gt;date;//将删除q的值域的值赋值给e的位置值 delete q; return 1;&#125; 求最大值123456789101112131415void mlist(lk l)&#123;//最大值 lk s=new ln; lk p=l-&gt;next; s-&gt;data=p-&gt;data; while(p)&#123; if(s-&gt;data&lt;=p-&gt;data)&#123; s-&gt;data=p-&gt;data; p=p-&gt;next; &#125; else&#123; p=p-&gt;next; &#125; &#125; cout&lt;&lt;"最大值为："&lt;&lt;s-&gt;data&lt;&lt;endl;&#125; 逆序输出123456789101112int rlist(lk &amp;l)&#123;//逆序 lk p=l-&gt;next; lk q; l-&gt;next=NULL; while(p)&#123; q=p-&gt;next; p-&gt;next=l-&gt;next; l-&gt;next=p; p=q; &#125; return 1;&#125; 合并12345678910111213141516171819void mergelist(lk &amp;la,lk &amp;lb,lk &amp;lc)&#123; lk pa=la-&gt;next; lk pb=lb-&gt;next; lk pc=lc=la; while(pa&amp;&amp;pb)&#123; if(pa-&gt;data&lt;pb-&gt;data)&#123; pc-&gt;next=pa; pc=pa; pa=pa-&gt;next; &#125; else&#123; pc-&gt;next=pb; pc=pb; pb=pb-&gt;next; &#125; &#125; pc-&gt;next=pa?pa:pb;&#125; 查找123456789101112131415161718192021int max(lk &amp;la)&#123; lk pa=la-&gt;next;//将pa指针指向la表的头结点 lk ps=la;//ps的初始值指向la的头结点 int i=1,k=0;//定义两个计数变量 ps-&gt;data=pa-&gt;data;//给ps的数据域赋初值 while(pa)&#123; if(pa-&gt;data&gt;=ps-&gt;data)&#123; ps-&gt;data=pa-&gt;data;//将ps的数据域指向pa的数据域 pa=pa-&gt;next;//向下移一位 k=i;//满足条件用k记录 i++;//循环计数+1 &#125; else&#123; pa=pa-&gt;next; i++;//循环计数+1 &#125; &#125; cout&lt;&lt;"最大元素是："&lt;&lt;ps-&gt;data&lt;&lt;endl; cout&lt;&lt;"位置是第"&lt;&lt;k&lt;&lt;"个元素"&lt;&lt;endl; return 1;&#125; 折半查找12345678910111213int xfind(lk st,keyt t, int low, int high)&#123; if(low&lt;=high)&#123; int mid=(low+high)/2; if(st.elem[mid].key==t) return mid; else if (st.elem[mid].key&lt;t) return (xfind(st, t, mid+1, high)); else return (xfind(st, t, low, mid-1)); &#125; else return 0;&#125; 完整程序(插入,删除,最大,合并,逆序)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212#include&lt;iostream&gt;using namespace std;typedef struct ln&#123; int data; struct ln *next;&#125;*lk;int initlist(lk &amp;l)&#123; l=new ln; l-&gt;next=NULL; return 1;&#125;int insertlist(lk &amp;l,int i,int e)&#123; lk p=l;//错写成p=l-&gt;next int j=0; while(p&amp;&amp;j&lt;i-1)&#123; p=p-&gt;next; j++; &#125; if(!p||j&gt;i-1)&#123; return 0; &#125; lk s=new ln; s-&gt;data=e; s-&gt;next=p-&gt;next; p-&gt;next=s; return 1;&#125;int deletelist(lk &amp;l,int i,int &amp;e)&#123; lk p=l;//错写成p=l-&gt;next int j=0; while(p&amp;&amp;j&lt;i-1)&#123; p=p-&gt;next; j++; &#125; if(!p||j&gt;i-1)&#123; return 0; &#125; lk q=p-&gt;next; p-&gt;next=q-&gt;next; e=q-&gt;data; delete q; return 1;&#125;int margeinlist(lk &amp;la,lk &amp;lb,lk &amp;lc)&#123;//合并 lk pa=la-&gt;next; lk pb=lb-&gt;next; lk pc=lc=la; while(pa&amp;&amp;pb)&#123; if(pa-&gt;data&lt;pb-&gt;data)&#123; pc-&gt;next=pa; pc=pa; pa=pa-&gt;next; &#125; else&#123; pc-&gt;next=pb; pc=pb; pb=pb-&gt;next; &#125; &#125; pc-&gt;next=pa?pa:pb; return 1;&#125;int rlist(lk &amp;l)&#123;//逆序 lk p=l-&gt;next; lk q; l-&gt;next=NULL; while(p)&#123; q=p-&gt;next; p-&gt;next=l-&gt;next; l-&gt;next=p; p=q; &#125; return 1;&#125;void mlist(lk l)&#123;//最大值 lk s=new ln; lk p=l-&gt;next; s-&gt;data=p-&gt;data; while(p)&#123; if(s-&gt;data&lt;=p-&gt;data)&#123; s-&gt;data=p-&gt;data; p=p-&gt;next; &#125; else&#123; p=p-&gt;next; &#125; &#125; cout&lt;&lt;"最大值为："&lt;&lt;s-&gt;data&lt;&lt;endl;&#125;void disp(lk &amp;l)&#123; lk p=l-&gt;next; if(!p)&#123; cout&lt;&lt;"空表"&lt;&lt;endl; &#125; while(p)&#123; cout&lt;&lt;p-&gt;data; p=p-&gt;next; &#125; cout&lt;&lt;endl;&#125;int main()&#123; lk la,lb,lc; int e; initlist(la); initlist(lb); insertlist(la, 1, 1); insertlist(la, 2, 5); insertlist(la, 3, 7); insertlist(la, 4, 9); insertlist(lb, 1, 2); insertlist(lb, 2, 3); insertlist(lb, 3, 6); cout&lt;&lt;"la的元素是："; disp(la); cout&lt;&lt;"lb的元素是："; disp(lb); deletelist(la, 2, e); cout&lt;&lt;"删除的元素是："&lt;&lt;e&lt;&lt;endl; margeinlist(la, lb, lc); cout&lt;&lt;"合并后的元素是："; disp(lc); rlist(lc); cout&lt;&lt;"反序输出元素顺序为："; disp(lc); mlist(lc);&#125;#include &lt;iostream&gt;using namespace std;typedef char et;typedef struct ln&#123; et date; struct ln *next;&#125;ln,*lk;int initlist(lk &amp;l)&#123; l=new ln; l-&gt;next=NULL; return 1;&#125;int listinsert(lk &amp;l,int i,et e)&#123; lk p; p=l; int j=0; while(p&amp;&amp;j&lt;i-1)&#123; p=p-&gt;next; j++; &#125; if (!p||j&gt;i-1) &#123; return 0; &#125; lk s=new ln; s-&gt;date=e;//将e的值赋值给s的值域 s-&gt;next=p-&gt;next;//新元素s的指针域指向旧元素p的指针域 p-&gt;next=s;//将p的指针域指向s元素 return 1;&#125;int listdelete(lk &amp;l,int i,et &amp;e)&#123; lk p; p=l; int j=0; while(p-&gt;next&amp;&amp;j&lt;i-1)&#123; p=p-&gt;next; j++; &#125; if (!(p-&gt;next)||j&gt;i-1) &#123; return 0; &#125; lk q; q=p-&gt;next;//q的指针指向p的指针域 p-&gt;next=q-&gt;next;//p的指针域指向q的指针域 e=q-&gt;date;//将删除q的值域的值赋值给e的位置值 delete q; return 1;&#125;void disp(lk l)&#123; lk p=l-&gt;next; if (!p) &#123; cout&lt;&lt;"此链表为空"&lt;&lt;endl; &#125; while (p) &#123; cout&lt;&lt;p-&gt;date; p=p-&gt;next; &#125; cout&lt;&lt;endl;&#125;int main()&#123; lk l; et e; initlist(l); disp(l); listinsert(l, 1, 'A'); listinsert(l, 2, 'B'); listinsert(l, 3, 'C'); disp(l); listdelete(l, 2, e); cout&lt;&lt;"删除的元素是："&lt;&lt;e&lt;&lt;endl; disp(l); return 0;&#125; 完整代码(查找)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt;using namespace std;typedef struct ln&#123; int data; struct ln *next;&#125;*lk;int inilist(lk &amp;l)&#123; l=new ln; l-&gt;next=NULL; return 1;&#125;int listinsert(lk &amp;l,int i,int e)&#123; lk p=l;//定义一个指针p指向l的头结点 int j=0;//位置的初始值 while (p&amp;&amp;j&lt;i-1) &#123; p=p-&gt;next;//当满足条件是p指向下一位 j++;//位置值加一 &#125; if (!p||j&gt;i-1) &#123; return 0; &#125; lk s=new ln;//建立一个节点s s-&gt;data=e;//s节点的数据域等于e的数值 s-&gt;next=p-&gt;next;//s的next域指向p的next域 p-&gt;next=s;//p的next域指向s节点 return 1;&#125;int max(lk &amp;la)&#123; lk pa=la-&gt;next;//将pa指针指向la表的头结点 lk ps=la;//ps的初始值指向la的头结点 int i=1,k=0;//定义两个计数变量 ps-&gt;data=pa-&gt;data;//给ps的数据域赋初值 while(pa)&#123; if(pa-&gt;data&gt;=ps-&gt;data)&#123; ps-&gt;data=pa-&gt;data;//将ps的数据域指向pa的数据域 pa=pa-&gt;next;//向下移一位 k=i;//满足条件用k记录 i++;//循环计数+1 &#125; else&#123; pa=pa-&gt;next; i++;//循环计数+1 &#125; &#125; cout&lt;&lt;"最大元素是："&lt;&lt;ps-&gt;data&lt;&lt;endl; cout&lt;&lt;"位置是第"&lt;&lt;k&lt;&lt;"个元素"&lt;&lt;endl; return 1;&#125;int main()&#123; lk la;//定义三个表 inilist(la);//对表la的初始化 listinsert(la, 1, 2);//向la表中插入数据 listinsert(la, 2, 3); listinsert(la, 3, 5); listinsert(la, 4, 7); listinsert(la, 5, 10); listinsert(la, 6, 9); listinsert(la, 7, 8); max(la);&#125; 完整代码(折半查找)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293//// main.cpp// 实验六数据结构//// Created by PC-MAC on 2018/12/3.// Copyright © 2018 PC-MAC. All rights reserved.//#include"iostream"using namespace std;const int tmax=10;typedef int keyt;typedef struct&#123; keyt key;&#125;elemtype;//每行内容typedef struct&#123; elemtype *elem; int length;&#125;lk;int find(lk st,keyt key)&#123; int i; st.elem[0].key=key; for(i=st.length;st.elem[i].key!=key;i--); return i;&#125;int twofind(lk st,keyt key)&#123; int low,high,mid; low=1; high=st.length; while(low&lt;=high)&#123; mid=(low+high)/2; if(st.elem[mid].key==key) return mid; else if(st.elem[mid].key&gt;key) high=mid-1; else low=mid+1; &#125; return 0;&#125;int xfind(lk st,keyt t, int low, int high)&#123; if(low&lt;=high)&#123; int mid=(low+high)/2; if(st.elem[mid].key==t) return mid; else if (st.elem[mid].key&lt;t) return (xfind(st, t, mid+1, high)); else return (xfind(st, t, low, mid-1)); &#125; else return 0;&#125;int main()&#123; keyt a[]=&#123;0,13,24,35,32,65,19,7,74,20,38&#125;; lk t; t.elem=new elemtype[tmax]; t.length=10; for(int i=1;i&lt;=10;i++)&#123; t.elem[i].key=a[i]; &#125; cout&lt;&lt;"查找到的元素位置为："&lt;&lt;find(t, 35)&lt;&lt;endl; lk s; s.elem=new elemtype[tmax]; s.length=10; keyt b[]=&#123;0,2,4,6,8,10,12,14,16,18,20&#125;; for(int k=1;k&lt;=10;k++)&#123; s.elem[k].key=b[k]; &#125; cout&lt;&lt;"折半查找到的元素位置为："&lt;&lt;twofind(s, 14)&lt;&lt;endl; int i, j; keyt arr[10]; for (i = 0; i &lt; 10; i++) &#123; arr[i] = i * 2; &#125; cout &lt;&lt; "输入查找数字:"; cin &gt;&gt; j; lk P; P.elem = new elemtype; P.length = 10; for (int j = 1; j &lt;= 10; j++) &#123; P.elem[j].key = arr[j]; &#125; cout&lt;&lt;"递归折半查找到的元素位置为："&lt;&lt;xfind(P, j, 0, 10)&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>经验</tag>
        <tag>期末</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[更换域名方法]]></title>
    <url>%2F2019%2F02%2F09%2F%E6%9B%B4%E6%8D%A2%E5%9F%9F%E5%90%8D%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Blog更换域名教程更换流程 1.更改域名解析； 2.更改站点配置文件URL； 3.改变CNAM中的域名； 4.改变robots.txt中，Sitemap字段； 5.查看Github中域名绑定是否更改； 6.对Google爬虫进行站点验证及添加； 更换域名解析在自己的域名控制台中导出自己之前绑定改过的域名，并在新的域名解析中添加。 更改站点配置文件URL进入站点配置文件，更改字段：url: https://xxx.com 改变CNAM中的域名打开你的blog目录，source/CNAME，直接添加即可。 CNAME会直接关联Github的域名绑定 改变robots打开你的blog目录，source/robots.txt中，改变Sitemap字段添加你的域名地址。 为了给爬虫robots做引导 在Github中域名绑定查看Github中域名绑定是否更改，具体位置在你的库文件下的域名绑定模块。 对Google爬虫进行站点验证及添加点击地址自行添加：https://www.google.com/webmasters/tools/home?hl=zh-CN]]></content>
      <categories>
        <category>域名</category>
        <category>教程</category>
      </categories>
      <tags>
        <tag>域名</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小米Pro15.6 安装黑苹果兼MacOS Mojave安装教程]]></title>
    <url>%2F2019%2F02%2F03%2F%E5%B0%8F%E7%B1%B3PRO%E5%AE%89%E8%A3%85%E9%BB%91%E8%8B%B9%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[小米Pro15.6 安装黑苹果兼MacOS Mojave安装教程写作/安装流程 1.下载镜像； 2.刻盘； 3.安装； 4.替换/完善EFI； Windows下制作macOS Mojave安装盘准备工具 U盘大于8G U 盘大小不限做 PE 盘 系统镜像下载：文章结尾 etcher 制作安装镜像 镜像制作 下载etcher 打开镜像 选择U盘 点击Flash即可 小米BIOS设置开机按F2进入BIOS设置 Security（1） 选择Set Supervisor Password，在Enter New Password这里输入密码，然后在Enter New Password Again这里重复输入密码，这一步是设置进入BIOS的密码。 Security（2） 再次进BIOS，依然在Security分类里选择Secure Boot Mode选项，将其设置为Disable，关闭安全模式。最后按F10，对你的刚才的设置进行保存并退出。 安装系统开机，按F12选择U盘引导 进入CLOVER主界面，直接回车，开始引导mac OS 很多的机友都是会在这个地方翻车。出现问题请私聊我反馈，请提供翻车照片及机器配置图。不提供任何信息直接发问就是耍流氓 这个过程需要1-2分钟,耐心等待，进入安装程序,出现语言选择界面 选择简体中文，点击继续 出现安装向导，点击继续 阅读许可协议，点击继续 点击同意，继续 出现安装界面，这里是让你选择安装磁盘 请点击菜单上面的实用工具-&gt;磁盘工具 出现磁盘工具，在磁盘工具里面所做的操作涉及到你的数据安全，请认真仔细确认后再操作，否则由此造成的一切后果本站概不承担。 点击窗口左上角的显示，选择显示所有设备 选择APPLE SSD macOS-0 SSD Media本例中为虚拟机中的磁盘名称，请根据你的设备选择相应的磁盘 点击抹掉， 假设您的磁盘是空的或者数据是已经备份过的,别怪我没提醒你!!! 在弹出的窗口中输入：名称：Mac；格式：Mac OS扩展(日志式)（10.13.X以上版本）APFS（10.14.X以上版本）；方案：GUID分区图，在点击抹掉按钮之前，请再次确认你的磁盘已经提前做了数据备份 点击抹除，然后等待操作结束 点击完成，通过菜单选择退出磁盘工具或者按窗口左上角红色按钮离开磁盘工具 返回到安装界面 选择Mac磁盘，点击继续 它会把USB安装盘上的安装文件预复制到要安装的系统分区里，这个过程通常会持续1-2分钟 重启后继续安装，在安装期间，通常会自动重启2-3遍 之所以有重启的动作是因为从Mac OS 10.13.x开始，苹果公司将默认的HFS磁盘分区强行换成APFS分区，它会在第二次重启之后做HFS-&gt;APFS转换的动作，转换成功后，继续安装过程。 重启重点第一次重启事实上Mac OS，已经完成的解压到了硬盘上，就跟Windows中拷贝U盘文件道理是一样的。 所以无论是第几次重启，哪怕是第一次，也可以直接进入Windows系统继续如下操作，因为这个时候Mac的基本配置文佳已经拷贝完成了。 合并或粘贴EFI脱离USB运行[Windows篇单硬盘版]基于最新版本的MacOS是不继承任何EFI 的，也就是说除了集成Clover，没有任何驱动的配置，所以若U盘中不替换EFI是无法正常启动桌面的，尽管配置成功，开机跑代码也会提示。所以这个时候就要借着重启的机会，提前合并粘贴EFI文件。 重启电脑正常开机进入Windows桌面，打开DG（DiskGenius分区工具）找到ESP分区，点击右侧的浏览文件 合并EFI打开ESP文件夹（这里要注意的是，现在有的文件夹，都是Windows的，一定不要直接删除，否则Win系统无法开机） 再次强调，若之前安装过Win系统，想要做双系统的朋友，只需要拷贝EFI文件中的CLOVER文件夹即可！剩下的都不需要动。用快捷键粘贴进去。 粘贴以后的样子，可能会多出一个APPLE文件夹，不需要搭理。 [Windows篇双硬盘版]重启电脑正常开机进入Windows桌面，打开DG（DiskGenius分区工具）找到ESP分区，点击右侧的浏览文件 这里我就不放图了，原理与单硬盘版相同，只不过是找到你安装Mac OS的那个硬盘 粘贴EFI直接将EFI文件夹里面的所有文件复制到ESP分区,这里给大家看一下我的，直接带着EFI粘贴进去就可以了里面的都不要管 添加启动项到BIOS[Windows篇单硬盘版]打开BOOTICE，看图操作，图上有序号 添加盘符 设置启动项添加盘符以后，添加启动项，并且改变启动项的顺序，若开机为Clover启动，请调执第一位。 [Windows篇双硬盘版]开机进BIOS设置启动项顺序，一般主板应该是boot选项卡中调节，调第一启动项为你的Mac OS分区。 继续执行Mac OS 的重启 重启重点这时候你可以拔掉U盘扔掉了。 本次重启是继续之前未完成的重启，进入你的Mac OS的安装的硬盘（这里Mac OS 的安装硬盘因为拔掉了U盘并且替换好EFI应该就只有一个了），继续安装系统时的重启过程 第二阶段重启第二阶段的安装会有两种界面,一种是不进安装界面直接安装,另一种是先进入安装界面直接安装,需要注意的是,无论是哪一种界面下,安装的过程中全程是禁用鼠标和键盘的,需要你做的只是耐心等待它安装完成 设置向导选择国家：中国 设置键盘 你可以添加自己熟悉的输入法，然后点击继续，出现数据与隐私，阅读后点击继续 选择不传输任何信息，点击继续 点击稍后设置 出现您确定要中法使用Apple ID来登录吗？，点击跳过 出现条款与条件，点击同意 出现我已经阅读并同意&quot;macOS软件许可协议&quot;，点击同意 出现创建电脑用户的窗口,输入用户名和密码,点击继续 创建电脑用户用户自己编辑 系统会创建初始用户，接着进行快捷设置 弹出界面，让你选择外观，您可以根据个人的喜好选择浅色主题或者深色主题，点击继续 出现正在设置您的Mac,请稍候完成设置向导 设置向导完成，根据选择主题的不同，分别进入不同的界面 进入桌面 出现桌面后,整个的安装向导就完成了。 安装后的系统设置如果没有什么问题，看到开机页面了，那么聪明的你说明你的黑苹果系统已经安装成功了。 快捷键的小修改很多人习惯了Windows，所以这里的快捷键做一下调整，如下修改就可以了 下载链接MacOS：链接: https://pan.baidu.com/s/1z96tO0D0cZu0EU5McNG09A 提取码: iusp 12.28EFI：链接: https://pan.baidu.com/s/1t2dHHV0uFYRSVe-IA4wRBQ 提取码: n4ff 鸣谢与支持Mac OS、EFI文件及部分文章图片转载于黑果小兵的部落阁 文章如又不懂的地方，可以添加我的微信，或者QQ，952339610，即可在线咨询！]]></content>
      <categories>
        <category>黑苹果</category>
        <category>教程</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>黑苹果</tag>
        <tag>小米</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub-Hexo-搭建个人网站详细教程]]></title>
    <url>%2F2019%2F01%2F29%2FGitHub-Hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[什么是Hexo ? Hexo是一款基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub和Heroku上，是搭建博客的首选框架。这里我们选用的是GitHub，你没看错，全球最大的同性恋交友网站（逃……）。Hexo同时也是GitHub上的开源项目，参见：hexojs/hexo 如果想要更加全面的了解Hexo，可以到其官网 Hexo 了解更多的细节，因为Hexo的创建者是台湾人，对中文的支持很友好，可以选择中文进行查看。这里，默认各位猿/媛儿都知道GitHub就不再赘述。 这是我的个人博客效果: TheMrxk· Blog 下面正式从零开始搭建年轻人的第一个网站。 搭建步骤： 获得个人网站域名 GitHub创建个人仓库 安装Git 安装Node.js 安装Hexo 推送网站 绑定域名 常用的Hexo 命令 更换主题 个性化设置 添加播放器 发布文章 获得个人网站域名域名是网站的入口，也是网站的第一印象，比如饿了么的官网的域名是：https://www.ele.me/ ，很是巧妙。常见的有com,cn,net,org等后缀，也有小众的xyz,me,io等后缀，根据你自己的喜好，选择不同的后缀，比如我选择就是常见的com后缀。很多小众奇特的后缀在大陆是没办法备案的，网站也就无法上线。然而使用GitHub托管我们的网站，完全不需要备案，因为托管我们的网站内容的服务器在美国，而且在国内备案流程也比较繁杂，时间需要一周左右。 申请域名的地方有很多，这里推荐阿里云：阿里云-为了无法计算的价值 申请入口：域名注册 购买域名这也是我们整个搭建过程中惟一一个需要花钱的地方。如果你已经有了空闲域名就无需购买，直接使用即可。 GitHub创建个人仓库登录到GitHub,如果没有GitHub帐号，使用你的邮箱注册GitHub帐号：Build software better, together 点击GitHub中的New repository创建新仓库，仓库名应该为：用户名.http://github.io 这个用户名使用你的GitHub帐号名称代替，这是固定写法，比如我的仓库名为： 安装Git什么是Git ?简单来说Git是开源的分布式版本控制系统，用于敏捷高效地处理项目。我们网站在本地搭建好了，需要使用Git同步到GitHub上。从Git官网下载：Git - Downloading Package 现在的机子基本都是64位的，选择64位的安装包，下载后安装。 在命令行里输入git测试是否安装成功。 首先查看电脑是否安装的Git，终端输入： 1git 安装过则会输出：即表示成功安装 若安装失败，参看其他详细的Git安装教程。 Mac终端为例直接输入： 1brew install git 安装成功后，将你的Git与GitHub帐号绑定， 创建ssh key，配置git1，设置用户名和电子邮件（Github上每次提交都会记录他们） 12git config --global user.name &quot;你的GitHub用户名&quot;git config --global user.email &quot;你的GitHub邮箱&quot; 2，通过终端命令创建ssh密钥 1ssh-keygen -t rsa -C &quot;你的GitHub邮箱&quot; `952339610@qq.com`是我的邮件名，回车会有以下输出 1234567Last login: Sat Jan 6 14:12:16 on ttys000WMBdeMacBook-Pro:~ *******$ ssh-keygen -t rsa -C "952339610@qq.com"Generating public/private rsa key pair.Enter file in which to save the key (/Users/*******/.ssh/id_rsa): /Users/*******/.ssh/id_rsa already exists.Overwrite (y/n)? nWMBdeMacBook-Pro:~ *******$ 由于这里我原来已经创建过，这里我选n，没有创建过的，会要求确认路径和输入密码，我们这使用默认的一路回车就行。成功的话会在〜/下生成.ssh文件夹，进去，打开id_rsa.pub，复制里面的关键。 终端查看.ssh/id_rsa.pub文件 1open .ssh/id_rsa.pub 回车后，就会新弹出一个终端，然后复制里面的关键字段。 3，打开GitHub_Settings_keys 页面，新建new SSH Key Title：随便写 Key：粘贴刚刚复制的关键字 最后点击Add SSH key。 在Git Bash中检测GitHub公钥设置是否成功。 输入 ： 1ssh git@github.com 如上则说明成功。这里之所以设置GitHub密钥原因是，通过非对称加密的公钥与私钥来完成加密，公钥放置在GitHub上，私钥放置在自己的电脑里。GitHub要求每次推送代码都是合法用户，所以每次推送都需要输入账号密码验证推送用户是否是合法用户，为了省去每次输入密码的步骤，采用了ssh，当你推送的时候，git就会匹配你的私钥跟GitHub上面的公钥是否是配对的，若是匹配就认为你是合法用户，则允许推送。这样可以保证每次的推送都是正确合法的。 安装Node.jsHexo基于Node.js，Node.js下载地址：Download | Node.js 下载安装包，注意安装Node.js会包含环境变量及npm的安装，安装后。 检测Node.js是否安装成功，在终端中输入 1node -v 检测npm是否安装成功，在终端中输入 1npm -v 到这了，安装Hexo的环境已经全部搭建完成。 安装Hexo1.终端下使用npm命令安装Hexo，输入 1npm install -g hexo-cli 这个安装时间较长耐心等待，安装完成后。注：这个时候可能会报错，没有关系正常现象。 2.安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。初始化我们的博客路径为默认路径，输入（folder为文件名） 123hexo init &lt;folder&gt;cd &lt;folder&gt;npm install 注意，这里的命令都是作用在刚刚创建的文件夹中。 为了检测我们的网站雏形，分别按顺序输入以下三条命令： 1hexo g &amp;&amp; hexo s 过了漫长的等待如果http://localhost:4000/成功打开，那么就说明博客基本建立完成。 推送站点上面只是在本地预览，接下来要做的就是就是推送网站，也就是发布网站，让我们的网站可以被更多的人访问。在设置之前，需要解释一个概念，在blog根目录里的_config.yml文件称为站点配置文件，如下图 进入根目录里的themes文件夹，里面也有个_config.yml文件，这个称为主题配置文件，如下图 下一步将我们的Hexo与GitHub关联起来，打开站点的配置文件_config.yml，翻到最后修改为： 1234deploy: type: gitrepo: 这里填入你之前在GitHub上创建仓库的完整路径，记得加上 .gitbranch: master 参考如下： 保存站点配置文件。 其实就是给hexo d 这个命令做相应的配置，让hexo知道你要把blog部署在哪个位置，很显然，我们部署在我们GitHub的仓库里。最后安装Git部署插件，输入命令： 1npm install hexo-deployer-git --save 这时，我们分别输入命令： 1hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 完成后，打开浏览器，在地址栏输入你的放置个人网站的仓库路径，即 http://xxxx.github.io (比如我的xxxx就是我的GitHub用户名： 1TheMrxk.github.io 你就会发现你的博客已经上线了，可以在网络上被访问了。 绑定域名虽然在Internet上可以访问我们的网站，但是网址是GitHub提供的:http://xxxx.github.io ，而我们想使用我们自己的个性化域名，这就需要绑定我们自己的域名。这里演示的是在阿里云的域名绑定，在国内主流的域名代理厂商也就阿里云和腾讯云。登录到阿里云，进入管理控制台的域名列表，找到你的个性化域名，进入解析 第一步，包括添加三条解析记录，192.30.252.153是GitHub的地址，你也可以ping你的 http://xxxx.github.io 的ip地址，填入进去。第三个记录类型是CNAME，CNAME的记录值是：你的用户名.http://github.io 这里千万别弄错了。 第二步，登录GitHub，进入之前创建的仓库，点击settings，设置Custom domain，输入你的域名点击save保存。 第三步，进入本地博客文件夹 ，进入blog/source目录下，创建一个记事本文件，输入你的域名，对，只要写进你自己的域名即可。如果带有www，那么以后访问的时候必须带有www完整的域名才可以访问，但如果不带有www，以后访问的时候带不带www都可以访问。所以建议，不要带有www。这里我还是写了www(不建议带有www): 保存，命名为CNAME ，注意保存成所有文件而不是txt文件。 完成这三步，进入blog目录中，按住shift键右击打开命令行，依次输入： 1hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 这时候打开浏览器在地址栏输入你的个性化域名将会直接进入你自己搭建的网站。 配置站点常用的Hexo 命令123npm install hexo -g #安装Hexonpm update hexo -g #升级 hexo init #初始化博客 12345678命令简写hexo n &quot;我的博客&quot; == hexo new &quot;我的博客&quot; #新建文章hexo g == hexo generate #生成hexo s == hexo server #启动服务预览hexo d == hexo deploy #部署综合hexo clean &amp;&amp; hexo g &amp;&amp; hexo s #清除缓存生成及预览hexo clean &amp;&amp; hexo g -d #清除缓存生成及上传 12345hexo server #Hexo会监视文件变动并自动更新，无须重启服务器hexo server -s #静态模式hexo server -p 5000 #更改端口hexo server -i 192.168.1.1 #自定义 IPhexo clean #清除缓存，若是网页正常情况下可以忽略这条命令 更换主题先下载好你喜欢的主题，例如我的NexT，将站点主题拖动到themes的文件夹中，在站点配置文件中, 将theme字段改为next 1theme: next 个性化设置参考文献： 梯子客户端收录 hexo的next主题个性化配置教程 添加播放器打开网页版的网易云音乐，选择喜欢的音乐，点击生成外链播放器 复制外链的代码 在侧栏插入这首歌的音乐播放器，修改 blog\themes\next\layout_macro的sidebar.swig文件，添加刚刚复制的外链代码 重新生成、部署网页，效果如下 写作方法发布文章我们开始正式发布上线博客文章，在命令行中输入： 1hexo n "博客名字" 我们会发现在blog根目录下的source文件夹中的_post文件夹中多了一个 博客名字.md 文件，使用Markdown编辑器打开，就可以开始你的个人博客之旅了，Markdown常用的样式也就十来种，完全能够满足一般博文的样式要求，Mac推荐Typora。 给博客插入图片 1.首先把blog（hexo）目录下的_config.yml里的 1psot_asset_folder:设置为true 2.在blog（hexo）目录下执行: 1npm install hexo-asset-image --save 3.在blog（hexo）目录下Git Bash Here，运行hexo n “博客名”来生成md博客时，会在_post目录下看到一个与博客同名的文件夹。 4.将想要上传的图片先扔到文件夹下，然后在博客中使用markdown的格式引入图片： 1![你想要输入的替代文字](xxxx/图片名.jpg) ps：因为博客名和文件夹名字相同，所以不需要绝对路径，只要xxxx是文件夹的名字就可以了。]]></content>
      <categories>
        <category>web前端</category>
        <category>个人博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Test Title]]></title>
    <url>%2F2019%2F01%2F23%2Ftest-title%2F</url>
    <content type="text"><![CDATA[Welcome to TheMrxk Blog1$ This Is My First Blog! Test a sentence1$ Hellow Word~ Thank you everyonePs:如果你手速足够快的快，估计你是第一个看我博客的人，17点之前私聊我微信，过来领2块钱红包！🧧 More info：By TheMrxk 小开哥]]></content>
      <categories>
        <category>web前端</category>
        <category>测试</category>
      </categories>
      <tags>
        <tag>Hello</tag>
        <tag>新建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F10%2F28%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
