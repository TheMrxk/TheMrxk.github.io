<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[错误:ids for this class must be manually assigned beforeQuery calling save(): com.hp.bean.UserBean详解]]></title>
    <url>%2F2019%2F09%2F01%2F%E9%94%99%E8%AF%AF-ids-for-this-class-must-be-manually-assigned-beforeQuery-calling-save-com-hp-bean-UserBean%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[错误:ids for this class must be manually assigned beforeQuery calling save():com.hp.bean.UserBean详解这个错误主要是 此类的id值为空（没有set该值 或 手工生成的值为null）spring映射文件没有设置为自动增长]]></content>
      <categories>
        <category>错误详解</category>
      </categories>
      <tags>
        <tag>BUG</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【TheMrxk】Win10_PRO专业版_x64_适度精简家用工作版v2.0]]></title>
    <url>%2F2019%2F09%2F01%2FWin10PRO%E4%B8%93%E4%B8%9A%E7%89%88v2-0%2F</url>
    <content type="text"><![CDATA[【TheMrxk】Win10_PRO专业版x64适度精简家用工作版v2.0【系统简介】 没有什么需要介绍的，牛逼，很强，用就完了，小T出品必是精品！ 【系统说明】 【v2.0系统说明】2019年8月24日更新：修复部分错误导致桌面重复图标 【v1.0系统说明】2019年8月21日更新：基于Windows 10 OS 17763.652 -1809制作优化，精简大量微软自带软件，还原一个纯净的系统，打入补丁和.Net3.5组件，集成个人优化方案。体积缩小80%释放后为9G左右。 【系统特点】 综合了一下朋友们的意见，在几个地方做了一些改动。1.开始菜单样式仿win7,（可更改回原来的样子）。2.取消精简版搜狗输入法（可在群内下载）。3.更新Microsoft Visual C++ 2015-2019 (14.22.27807)4.更新Adobe Flash Player AX/NP/PP 32.0.0.2235.补丁更新至7月最新 【如何安装】 本版本为无人值守版本 ，在PE环境下使用Dism++释放自己需要的版本，系统没有篡改锁定主页和添加垃圾软件的行为，请不要使用大X菜，老X桃，深度PE等含有广告性质的PE安装本系统！系统安装后，请勿使用腾讯管家 360，等软件优化系统，出现问题与本人无关！ 【免责声明】 本系统及软件来源于互联网，版权属各自产权人所有，仅用于临时测试PC硬件之用，不得用于商业用途，我不承担任何技术及版权问题，且不对任何资源负法律责任。所有资源请在下载后72小时内删除。制作安装镜像 【系统截图】 【系统下载】 【TheMrxk】Win10_PRO专业版x64适度精简家用工作版v2.0.esd百度网盘：链接：https://pan.baidu.com/s/1c38Wv9ssXLXJAymsUGYgAg提取码:请扫面屏幕下方二维码公告中获取（制作不易请谅解~） 【交流反馈】 个人博客：blog.orghub.cnQQ交流群：①群 ：70230004（小号误加,秒退误加）QQ：952339610]]></content>
      <categories>
        <category>Win10优化系统</category>
      </categories>
      <tags>
        <tag>Win10</tag>
        <tag>精简</tag>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[转载-Action层, Service层 和 Dao层的功能区分]]></title>
    <url>%2F2019%2F08%2F27%2FAction%E5%B1%82-Service%E5%B1%82-%E5%92%8C-Dao%E5%B1%82%E7%9A%84%E5%8A%9F%E8%83%BD%E5%8C%BA%E5%88%86%2F</url>
    <content type="text"><![CDATA[Action/Service/DAO简介：Action是管理业务（Service）调度和管理跳转的。Service是管理具体的功能的。Action只负责管理，而Service负责实施。DAO只完成增删改查，虽然可以1-n，n-n，1-1关联，模糊、动态、子查询都可以。但是无论多么复杂的查询，dao只是封装增删改查。至于增删查改如何去实现一个功能，dao是不管的。总结这三者，通过例子来解释：Action像是服务员，顾客点什么菜，菜上给几号桌，都是ta的职责；Service是厨师，action送来的菜单上的菜全是ta做的；Dao是厨房的小工，和原材料打交道的事情全是ta管。相互关系是，小工(dao)的工作是要满足厨师(service)的要求，厨师要满足服务员(action)转达的客户（页面用户）的要求，服务员自然就是为客户服务喽。现在最基本的分层方式，结合了SSH架构。Model层就是对应的数据库表的实体类。Dao层是使用了Hibernate连接数据库、操作数据库（增删改查）。Service层：引用对应的Dao数据库操作。Action层：引用对应的Service层，在这里结合Struts的配置文件，跳转到指定的页面，当然也能接受页面传递的请求数据，也可以做些计算处理。以上的Hibernate, Struts，都需要注入到Spring的配置文件中，Spring把这些联系起来，成为一个整体。 三大框架Struts/Hibernate/Spring简单地说：Struts——控制用的；Hibernate——操作数据库的；Spring——解耦用的。详细地说：Struts在SSH框架中起控制的作用，其核心是Controller，即ActionServlet，而ActionServlet的核心就是Struts-config.xml，主要控制逻辑关系的处理。Hibernate是数据持久化层，是一种新的对象、关系的映射工具，提供了从Java类到数据表的映射，也提供了数据查询和恢复等机制，大大减少数据访问的复杂度。把对数据库的直接操作，转换为对持久对象的操作。Spring是一个轻量级的控制反转(IoC)和面向切面(AOP)的容器框架。面向接口的编程，由容器控制程序之间的依赖关系，而非传统实现中，由程序代码直接操控。这就是所谓“控制反转”的概念所在：（依赖）控制权由应用代码中转到了外部容器，控制权的转移，是所谓反转。依赖注入，即组件之间的依赖关系由容器在运行期决定，形象地说，即由容器动态地将某种依赖关系注入到组件之中，起到的主要作用是解耦。Struts、Spring、Hibernate在各层的作用：（1）Struts负责Web层：ActionFormBean接收网页中表单提交的数据，然后通过Action进行处理，再Forward到对应的网页。在Struts-config.xml中定义，ActionServlet会加载。（2） Spring负责业务层管理，即Service（或Manager）。Service为action提供统计的调用接口，封装持久层的DAO；可以写一些自己的业务方法；统一的Javabean管理方法；声明式事务管理；集成Hibernate。（3）Hibernate，负责持久化层，完成对数据库的crud操作。提供OR/Mapping。它由一组.hbm.xml文件和POJO，是跟数据库中的表相对应的。然后定义DAO，这些是跟数据库打交道的类，它们会使用PO。 框架业务逻辑分析：在Struts + Spring + Hibernate的系统中，对象的调用流程是：JSP—Action—Service—DAO—Hibernate。数据的流向是：ActionFormBean接受用户的数据，Action将数据从ActionFormBean中取出，封装成VO或PO，再调用业务层的Bean类，完成各种业务处理后再Forward。而业务层Bean收到这个PO对象之后，会调用DAO接口方法，进行持久化操作。SSH框架的优点:Hibernate的最大好处就是根据数据库的表，反向生成实体类，并且还有关系在里面，还有就是它对数据的操作也很方便,Spring省去了在类里面new对象的过程，把这个调用与被调用的关系直接展示到了配置文件里，做任何操作都变得简单了。 简单流程举例说明:程序框架搭建好，并且把各种jar包导入后，就开始进行业务逻辑分析——假设一个最基本的注册功能：页面有两个文本框，一个用户名(username)和一个密码(password)。以QQ注册网页说明，这里以昵称和密码为代表进行 举例。首先是action层：它是负责在页面和程序之间传输数据的，还有作用是做页面跳转。页面由用户填写表单数据，点击提交按钮，页面的表单数据由Hibernate自动封装到该页面表单所对应的ActionFrom（ActionFrom跟实体类不是一个东西，ActionFrom是页面有什么值，类里就写什么属性，是用来封装表单数据用的；而实体类是完全按照数据库的字段生成的，实体类可以当做ActionFrom用，但ActionFrom绝对不可以当做实体类用），这样表单数据就以ActionFrom对象的形式在Action的点击“提交按钮”执行的那个方法里存在了。这个时候需要做的就是把表单数据存入数据库中。此时，Action的功能告一段落，接着是把数据传入BIZ层。 BIZE层（业务逻辑层）：负责的是对数据的处理。如果没有数据处理任务的话，此层只做单纯的数据传递作用，而后又到了DAO层。DAO层（数据库操作层）：负责对数据向数据库增删改查的操作.在该注册的框架中，如果不使用Spring的话，每个层之间的数据传递都需要new一个调用该层数据的类的实例。而使用了Spring的话，需要做的就是把DAO层和BIZ层的每个类都写一个接口类，接口类里写实现类的方法，在调用的时候不new对象，直接用对象点(.)方法就可以，别忘了对每个对象加上set/get方法。 文章转载自网络，如有侵权，立刻删除！]]></content>
      <categories>
        <category>框架</category>
        <category>教程</category>
      </categories>
      <tags>
        <tag>框架</tag>
        <tag>SSH-2</tag>
        <tag>Java-EE</tag>
        <tag>Struts</tag>
        <tag>Spring</tag>
        <tag>Hibernate</tag>
        <tag>Action</tag>
        <tag>Service</tag>
        <tag>Dao</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac使用Myeclipse搭建SSH2框架]]></title>
    <url>%2F2019%2F08%2F26%2FMac%E4%BD%BF%E7%94%A8Myeclipse%E6%90%AD%E5%BB%BASSH2%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[Mac使用Myeclipse搭建SSH2框架框架流程 1.创建一个Web Project项目； 2.添加Struts； 3.添加Spring； 4.添加一个数据库； 5.添加Hibernate链接； 创建一个Web Project项目 这里请根据自己需求来写，若改变其中内容，后续选项可能会稍有不同 添加架构如图所示，顺序123 添加Struts 安装的架包视情况而定 添加Spring 这里想文件位置改变为如图所示位置 添加一个数据库 在数据库软件中添加一个数据库，软件不限，不会请自行百度 切换到数据库视图，我们要将myeclipse链接到这个数据库 新建一个连接 1.使用的数据库语言 2.你要创建的链接名称 3.你的本地数据库地址 4.你的数据库用户名 5.你的数据库密码 6.添加驱动包 7.驱动bin包 8.设置驱动 9.保存密码 在第7步骤中需要下载数据库驱动jar包mysql-connector-java-5.1.47-bin.jar，具体百度获取。 注意是压缩包中 -bin 文件 测试是否连通，若出现错误，请检查上图中是否设置出错。如url，用户名，密码等。 添加Hibernate链接 Web测试 实战操作创建三个包 dao包的配置 添加用户页面.jsp 添加一个form表单 拖动即可 Emmmm…… 不知道为什么心中一万个曹尼玛在奔腾，老版本的拖动以后可以直接设置属性，而新版本只能右下角，最后决定还是自己手打吧，这么一个一个找实在是太费劲了，最后贴一下这段HTML代码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt; &lt;%@ taglib prefix="s" uri="/struts-tags" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;添加用户信息页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form style="height: 268px; " name="form1" method="post" action="AddUserAction"&gt; &lt;table width="409" border="1" height="222"&gt; &lt;tr&gt; &lt;td colspan="2" height="20 &gt; &lt;font color="red"&gt;&lt;s:actionmessage/&gt;&lt;/font&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;用户名：&lt;/td&gt; &lt;td&gt;&lt;input type="text" name="username"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;密码：&lt;/td&gt; &lt;td&gt;&lt;input type="password" name="password"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;专业：&lt;/td&gt; &lt;td&gt; &lt;select name="major"&gt; &lt;option value="信息管理"&gt;信息管理&lt;/option&gt; &lt;option value="软件工程"&gt;软件工程&lt;/option&gt; &lt;option value="嵌入式"&gt;嵌入式&lt;/option&gt; &lt;option value="信息化"&gt;信息化&lt;/option&gt; &lt;/select&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;年龄：&lt;/td&gt; &lt;td&gt;&lt;input type="text" name="age"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;性别：&lt;/td&gt; &lt;td&gt; &lt;input type="radio" checked="checked" value="男" name="sex"&gt;男 &lt;input type="radio" value="女" name="sex"&gt;女 &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;出生日期：&lt;/td&gt; &lt;td&gt;&lt;input type="text" name="birthday" value="yyyy-mm-dd"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan="2"&gt; &lt;input type="submit" name="button1" value="保存"&gt; &lt;input type="reset" name="button2" value="取消"&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; Servic包的配置 抽取出接口 最终代码 1234567891011121314151617181920212223242526272829303132333435363738package com.hekai.service;import java.util.List;import com.hekai.dao.User;import com.hekai.dao.UserDAO;public class UserServiceImpl implements UserService &#123; private UserDAO userDAO; /* (non-Javadoc) * @see com.hekai.service.UserService#getUserDAO() */ public UserDAO getUserDAO() &#123; return userDAO; &#125; /* (non-Javadoc) * @see com.hekai.service.UserService#setUserDAO(com.hekai.dao.UserDAO) */ public void setUserDAO(UserDAO userDAO) &#123; this.userDAO = userDAO; &#125; /* (non-Javadoc) * @see com.hekai.service.UserService#addUser(com.hekai.dao.User) */ public boolean addUser(User user) &#123; String username = user.getUsername(); List&lt;User&gt; userList = userDAO.findByUsername(username); if (userList.isEmpty()) &#123; userDAO.save(user); return true; &#125;else &#123; return false; &#125; &#125; &#125; Action包 这里需要注意导入ActionSupport包 同理 完整代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package com.hekai.action;import java.util.Date;import com.hekai.dao.User;import com.hekai.service.UserService;import com.opensymphony.xwork2.ActionSupport;public class AddUserAction extends ActionSupport &#123; private UserService userService; private String username; private String password; private String major; private Integer age; private String sex; private Date birthday; public UserService getUserService() &#123; return userService; &#125; public void setUserService(UserService userService) &#123; this.userService = userService; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public String getMajor() &#123; return major; &#125; public void setMajor(String major) &#123; this.major = major; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public Date getBirthday() &#123; return birthday; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; public String execute() throws Exception&#123; User user = new User(); user.setUsername(username); user.setPassword(password); user.setMajor(major); user.setAge(age); user.setSex(sex); user.setBirthday(birthday); if (userService.addUser(user)) &#123; this.addActionMessage("添加用户成功!"); &#125;else &#123; this.addActionMessage("用户名已经存在，请选择其他用户名，添加失败!"); &#125; return "success"; &#125;&#125; 添加页面出现的小问题无法连接数据库 分析了一下原因发现是数据库驱动的问题，添加了这段代码就可以了，不知道为什么没有自动生成 123&lt;property name="driverClassName" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt; 乱码问题乱码问题首先是在前台页面输如进来，在console打印的时候回出现乱码 后来解决办法如下，将软件内所有可以更改的地方都改成UTF-8，JSP,XML中改成GB2312 打开Window-&gt;Preferences选项完成中文编码设置。 打开MyEclipse-&gt;Files and Editors 设置Encoding为UTF-8设置ASP and PHP、CSS、DTD、HTML、JSP、XML中的Encoding为UTF-8（Mac中请善用搜索功能） 选择OK，保存设置。 JDBC在建立数据连接时也需要指定一下编码?characterEncoding=UTF-8。 1&lt;property name="url" value="jdbc:mysql://localhost:3306/sjk?characterEncoding=UTF-8"&gt;&lt;/property&gt; 设置统一编码将所有的.xml和.jsp文件的编码方式统一设置成GB2312。 项目流程 1.创建数据库-&gt;创建Hibernate-&gt;生成DAO文件; 2.创建JSP页面； 3.添加Service-&gt;class(xxxxImpl)-&gt;添加Boolean方法-&gt;抽取接口文件(xxxx)； 4.添加Action-&gt;添加actionsupport(xwork2)接口-&gt;调用接口等配置-&gt;； 5.修改applicationContext.xml配置文件； 6.修改suruts.xml跳转文件； Action中的方法中单个方法使用的例子 1&lt;form name="form1" action="ManagerAction?method=addManager" method="post"&gt; Action中的方法中直接使用方法的例子 1&lt;form name="form1" method="post" action="AddUserAction"&gt;]]></content>
      <categories>
        <category>框架</category>
        <category>教程</category>
      </categories>
      <tags>
        <tag>框架</tag>
        <tag>SSH-2</tag>
        <tag>Java-EE</tag>
        <tag>Struts</tag>
        <tag>Spring</tag>
        <tag>Hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设定断点并监听从接口获得的结果集]]></title>
    <url>%2F2019%2F08%2F19%2F%E8%AE%BE%E5%AE%9A%E6%96%AD%E7%82%B9%E5%B9%B6%E7%9B%91%E5%90%AC%E4%BB%8E%E6%8E%A5%E5%8F%A3%E8%8E%B7%E5%BE%97%E7%9A%84%E7%BB%93%E6%9E%9C%E9%9B%86%2F</url>
    <content type="text"><![CDATA[通过设定断点并监听从接口获得的结果集流程 1.设定一个debugger断点； 2.返回浏览器去打开检查； 3.双击选中要监听的字段； 4.右键选择Add selected text to watches； 设定一个debugger断点12345678910showPsSeverityType()&#123; var self = this; ClueCollectionApi.getCodeMaster(&#123;codeType: "SEVERITY_TYPE"&#125;).then(function(res)&#123; self.severitys = res.data.codeMasterList; debugger; self.form.severity = self.severitys[0].code; &#125;);&#125;, 返回浏览器去打开检查 双击选中要监听的字段 右键选择Add selected text to watches]]></content>
      <categories>
        <category>前端</category>
        <category>教程</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>断点</tag>
        <tag>监听</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过JSON实现本地页面传递]]></title>
    <url>%2F2019%2F08%2F08%2F%E9%80%9A%E8%BF%87JSON%E5%AE%9E%E7%8E%B0%E6%9C%AC%E5%9C%B0%E9%A1%B5%E9%9D%A2%E4%BC%A0%E9%80%92%2F</url>
    <content type="text"><![CDATA[通过JSON实现本地页面传递流程 1.创建一个要传递的数组； 2.存数据； 3.取数据； 4.完善； 创建一个要传递的数组123456789101112131415// 创建json数组var successJson = &#123; // 示例：clueContent: self.form.clueContent, clueTitle: self.form.clueTitle, // 标题 occurTime: self.form.occurTime, // 响应时间 clueContent: self.form.clueContent, // 内容 informerName: self.form.informerName, // 提交人 unit: self.form.unit, //责任单位 view: self.form.view, //处置意见 originalUrl: self.form.originalUrl, //舆情原址 label: self.form.label.join(" ")+"#", // 标签 sort: self.form.sort.join(" ")+"#", //分类 severity: self.form.severity.join(" ")+"#", //严重程度&#125;;console.log(successJson); 存数据123// 传递json中存数据var jsonStr = JSON.stringify(successJson);//将JSON转为字符串localStorage.successJson = jsonStr; // 将字符串存到 localStorage successJson 键下 取数据123// 从json中取数据var newUsers = JSON.parse(localStorage.successJson);// 转为JSONconsole.log(newUsers); // 打印出原先对象 完善12345678910// 严重程度self.form.clueExt2 = newUsers.severity.split("#")[0];// 分类self.form.clueExt1 = newUsers.sort.split("#")[0];// 标签self.form.clueExt4 = newUsers.label.split("#")[0]; // 责任单位 self.form.unit = newUsers.unit; // 处置意见 self.form.view = newUsers.view;]]></content>
      <categories>
        <category>前端</category>
        <category>教程</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>json</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[免费获得OneDrive 5T网盘及正版Office 365授权]]></title>
    <url>%2F2019%2F06%2F07%2F%E5%85%8D%E8%B4%B9%E8%8E%B7%E5%BE%97OneDrive-5T%E7%BD%91%E7%9B%98%E5%8F%8A%E6%AD%A3%E7%89%88Office-365%E6%8E%88%E6%9D%83%2F</url>
    <content type="text"><![CDATA[免费获得OneDrive 5T网盘及正版Office 365授权Onedrive是微软的网络硬盘，普通用户有5G的空间。今天介绍的方法可以达到5T的空间，而且方法简单、快速。 额外获得技能：永久使用最新版Office 365。 获取流程 1.注册临时邮箱； 2.注册Office365； 3.设置正版Office 365授权； 注册临时邮箱首先打开这个网站：http://24mail.chacuo.net/ ，随机或者自行设置一个临时邮箱。不要关闭这个网站。 然后打开网址：https://products.office.com/en-us/student?tab=students 输入 刚才的ID@stu.mao.office.gy 请注意上面加粗的邮箱地址！不是刚才的临时邮箱！ 注册Office365然后选老师或学生都无所谓。 然后回到刚才的临时邮箱页面F5刷新，查看验证码，如果没有的话就稍微等一会，2分钟以后还没有的话，就可以说重头再来了。 选择跳过。 进入页面以后打开OneDrive。 这个时候需要登录你的微软账号，默认的情况下会有登录记录，如下图。 验证一下你自己的邮箱。 这个地方需要填写真实的邮箱地址，教程中的图片仅供测试使用。 点击完成。 等待一段时间会出现下图的字样，点击进入即可。 点击设置按钮，点击OneDrive设置。 点击其他设置，存储标准，即可查看网盘大小。 设置正版Office 365授权访问如下链接：https://account.activedirectory.windowsazure.com/r/#/groups 点击加入组。 点击加入组。 加入理由随便写，然后点击请求。 然后关掉这个页面。 登录这个网址。https://login.microsoftonline.com并点击我的账户 再次查看，发现桌面版已授权。 注意事项：1、请勿用于存储重要资料！ 2、多次注册会被封号处理！ 3、如果不成功请看是不是完全按照我红色强调的做了！油管频道会在5月2日下午上视频教程。 4、请勿用于获利！ 如果你想完全卸载之前的盗版，请清除所有许可证，卸载所有密钥，清除服务器地址三步走！具体方法请自行搜索。]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>OneDrive网盘</tag>
        <tag>免费</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Win10LTSCv4.0]]></title>
    <url>%2F2019%2F06%2F06%2FWin10LTSCv4-0%2F</url>
    <content type="text"><![CDATA[【TheMrxk】Win10 LTSC企业版 x64 适度精简版v4.0【系统简介】 Win10 LTSC企业版一直是我最用心制作的一个系统，一方面系统本身是真的好用，一方面也是我的第一个自制系统，尽管上一个版本并不完善，但每个版本的系统我都会当做“儿子”来看待。So 请你们相信我，无论当前版本好与差，只要你们说不，我就会去改，会去更新，希望每一个用我系统的人都可以享受一份快乐而不是抱怨！ 【系统说明】 【v4.0系统说明】2019年5月7日更新：基于父版本制作而成，优化C:\Program Files (x86)不明来历文件夹，去除自动激活并添加激活工具在桌面AAct.exe（自动激活反响不是很好）【v3.1系统说明】2019年5月4日更新：优化自动激活功能，更改离线激活路径，增加激活成功率【v3.0系统说明】2019年5月2日更新：优化部分功能，添加离线自动激活功能（功能因时间推迟可能出现激活失败的情况，请自行百度激活）【v2.1系统说明】2019年4月25日更新：部分功能进行优化，无大改动【v2.0系统说明】2019年4月1日更新：修复1803系统官方存在的虚拟内存转移出错问题【v1.0系统说明】基于cn_windows_10_enterprise_ltsc_2019_x64_dvd_9c09ff24制作优化，精简大量微软自带软件，还原一个纯净的系统，打入补丁和.Net3.5组件，集成个人优化方案。体积缩小70%释放后为10G左右 【系统特点】 1.使用搜狗精简版输入法代替了微软拼音。2.开始菜单样式仿win7,（可更改回原来的样子）。3.迁移视频，收藏夹，图片，文档，下载，音乐为D盘，安装时请先分区，否则可能出现未知错误。 【如何安装】 本版本为无人值守版本 ，在PE环境下使用Dism++释放自己需要的版本，系统没有篡改锁定主页和添加垃圾软件的行为，请不要使用大X菜，老X桃，深度PE等含有广告性质的PE安装本系统！系统安装后，请勿使用腾讯管家 360，等软件优化系统，出现问题与本人无关！ 【免责声明】 本系统及软件来源于互联网，版权属各自产权人所有，仅用于临时测试PC硬件之用，不得用于商业用途，我不承担任何技术及版权问题，且不对任何资源负法律责任。所有资源请在下载后72小时内删除。制作安装镜像 【系统截图】 【系统下载】 【TheMrxk】Win10 LTSC企业版 x64 适度精简版v4.0百度网盘：链接:https://pan.baidu.com/s/14I7tO8kogL6Kt-BhD7ON0w密码:请扫面屏幕下方二维码公告中获取（制作不易请谅解~） 【交流反馈】 个人博客：blog.orghub.cnQQ交流群：①群 ：70230004（小号误加,秒退误加）QQ：952339610]]></content>
      <categories>
        <category>Win10优化系统</category>
      </categories>
      <tags>
        <tag>Win10</tag>
        <tag>精简</tag>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac安装MySQL数据库]]></title>
    <url>%2F2019%2F02%2F26%2FMac%E5%AE%89%E8%A3%85MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[Mac安装MySQL数据库及可视化界面安装介绍 1.安装MySQL； 2.安装MySQL Workbench； 3.常用代码； 安装MySQL下载最新的MySQL社区版为了安装更方便，建议下载dmg安装包。 最新的版本是8.0.15。 安装MySQL双击 mysql-8.0.15-macos10.14-x86_64.dmg 文件，加载镜像双击 mysql-8.0.15-macos10.14-x86_64.pkg ，开始安装 一直点击继续就可以安装成功。 注意：安装即将完成之后会弹出一个对话框，告诉我们生成了一个root账户让你设置一个密码。请注意保存，否则重设密码会比较麻烦。 如果安装完不能登录，稍后会告诉大家怎么解决忘记密码的问题。 启动MySQL打开系统偏好设置，会发现多了一个MySQL图标，点击它，会进入MySQL的设置界面： 安装之后，默认MySQL的状态是running，开启的。点击“Stop MySQL Server”按钮来可以它。下方还有一个复选框按钮，可以设置是否在系统启动的时候自动启动MySQL，默认是勾选的，建议取消，节省开机时间。 终端连接MySQL打开终端，为Path路径附加MySQL的bin目录 1PATH="$PATH":/usr/local/mysql/bin 然后通过以下命令登陆MySQL（密码就是前面设置的密码） 1mysql -u root -p 出现上面的提示就表示成功连接数据库了 低版本会出现的问题 如果较低版本会自动生成一个密码，这个密码需要记住，并且在连接是会发生以下问题，并附上解决办法 登陆成功，但是运行命令的时候会报错，提示我们需要重设密码。 1mysql&gt; show databases;ERROR 1820 (HY000): You must reset your password using ALTER USER statement before executing this statement.mysql&gt; 修改密码，新密码为123456 1set PASSWORD =PASSWORD('123456'); 再次执行show databases;就正常了。 安装时忘记密码 解决MAC下MySQL忘记初始密码的方法很多人在在安装的过程中忽略了初始密码，导致安装成功之后无法登陆不过只要大家注意安装过程中的提示，就不会再踩这个坑了😄 第一步点击系统偏好设置-&gt;最下边点MySQL，在弹出页面中，关闭服务 第二步进入终端输入 1cd /usr/local/mysql/bin/ 回车后 登录管理员权限 1sudo su 回车后输入以下命令来禁止mysql验证功能 1./mysqld_safe --skip-grant-tables &amp; 回车后mysql会自动重启（偏好设置中mysql的状态会变成running） 第三步输入命令 1./mysql 回车后，输入命令 1FLUSH PRIVILEGES 回车后，输入命令 1SET PASSWORD FOR 'root'@'localhost' = PASSWORD('你的新密码'); OK，可以了，新密码设置成功！！！ 安装MySQL Workbench MySQL Workbench是一款专为MySQL设计的ER/数据库建模工具。它是著名的数据库设计工具DBDesigner4的继任者。你可以用MySQL Workbench设计和创建新的数据库图示，建立数据库文档，以及进行复杂的MySQL 迁移。 下载最新的MySQL Workbench安装MySQL Workbench双击mysql-workbench-community-8.0.15-macos-x86_64.dmg 打开 把程序拖到文件夹，安装安装完成。 安装之后打开 启动MySQL Workbench新版本直接打开就回看到之前连接好的数据库，直接打开验证密码就可以连接了。 旧版本的需要添加一个数据库，如图下图 点击左上方的加号新建一个与数据库服务的连接 填写完信息之后，点击Test Connection 若出错，则我需要检查下： MySQL服务是否打开 在System Preferences中和Terminal查看。上面均有提到。 端口号是否一致 在Terminal中进入MySQL 输入命令： 12show global variables like 'port';//显示服务端口号 将显示的端口号填入，点击 1Test Connection 显示successful之后点击OK,则创建成功 点击创建的连接，进入管理界面 则安装和配置就完成(≧▽≦)/~啦啦啦 常用代码安装连接12345678910//为MySQL附加bin路径PATH="$PATH":/usr/local/mysql/bin//通过命令输入密码进入数据库mysql -u root -p//创建账号/usr/local/mysql/bin/mysqladmin -u root password 密码//测试mysql登陆/usr/local/mysql/bin/mysql -u root -p //显示服务端口号show global variables like 'port'; 完全卸载123456789sudo rm /usr/local/mysqlsudo rm -rf /usr/local/mysql*sudo rm -rf /Library/StartupItems/MySQLCOMsudo rm -rf /Library/PreferencePanes/My*edit /etc/hostconfig and remove the line MYSQLCOM=-YES-rm -rf ~/Library/PreferencePanes/My*sudo rm -rf /Library/Recipts/mysql*sudo rm -rf /Library/Receipts/MySQL*sudo rm -rf /private/var/db/receipts/*mysql* 终端命令启动或关闭1234// 启动：sudo /usr/local/mysql/support-files/mysql.server start// 关闭sudo /usr/local/mysql/support-files/mysql.server stop 进入或退出mysql1234// 进入mysql（要求输入mysql登录密码）mysql -u root -p// 退出mysqlexit]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java自学的经典题型总结]]></title>
    <url>%2F2019%2F02%2F20%2FJava%2F</url>
    <content type="text"><![CDATA[Java自学的经典题型总结经典题型 1.Hello Word 2.嵌套循环问题 3.定义一个类求圆的面积和周长 4.计算两点间的距离 5.定义一个类并打印其姓名和年龄 6.构造与重载定义个人信息 7.十进制对二进制八进制十六进制的转换 8.随机生成问题 9.数组的使用 Hello Word 程序猿的第一个程序 12345public class HelloWord &#123; public static void main(String[] args) &#123; System.out.println("Hello Word!!"); &#125;&#125; 嵌套循环问题 生成一个九九乘法表 1234567891011121314package 循环for嵌套;public class ForFor &#123; public static void main(String[] arge) &#123; int sum = 0; for(int i = 1 ;i &lt;= 9 ;i++) &#123; for(int j = 1;j &lt;= i ;j++) &#123; sum = i * j; System.out.print(i + "*" + j + "=" + sum + "\t"); &#125; System.out.println(); &#125; &#125;&#125; 定义一个圆类Circle 定义一个圆类——Circle. 在类的内部提供一个属性：半径(r). 同时 提供 两个 方法 ： 计算 面积 (getArea()) 和 计算 周长(getPerimeter()) 。 通过两个方法计算圆的周长和面积并且对计算结果进行输出。 最后定义一个测试类对 Circle 类进行使用。 123456789101112131415161718192021222324252627282930313233343536373839package 编码题2;import java.util.Scanner;/** * 定义一个圆类——Circle. * 在类的内部提供一个属性：半径(r). * 同时 提供 两个 方法 ： 计算 面积 (getArea()) 和 计算 周长(getPerimeter()) 。 * 通过两个方法计算圆的周长和面积并且对计算结果进行输出。 * 最后定义一个测试类对 Circle 类进行使用。 * @author pc-mac * */public class Circle &#123; double r; public static void main(String[] args) &#123; Circle n1 = new Circle(); System.out.println("###请输入圆的半径###"); Scanner n = new Scanner(System.in); int rString = n.nextInt(); n1.getArea(rString); n1.getPerimeter(rString); &#125; public void getArea(double r) &#123; this.r = r; System.out.println("面积是：" + Math.PI*r*r); &#125; public void getPerimeter(double r) &#123; this.r = r; System.out.println("周长是：" + Math.PI*r*2); &#125;&#125; 计算两点之间的距离1234567891011121314151617181920212223242526272829package 方法的构造;public class TestConstructor &#123; public static void main(String[] args) &#123; point p = new point(3.0,4.0); point p2 = new point(6.0,8.0); point or = new point(0,0); System.out.println(p.getDistance(or)); System.out.println(p2.getDistance(or)); &#125;&#125;class point&#123; //构造函数 public point (double _x,double _y)&#123; x = _x; y = _y; &#125; //属性 double x,y; //方法 public double getDistance(point p) &#123; return(Math.sqrt((x-p.x)*(x-p.x)+(y-p.x)*(y-p.y))); &#125;&#125; 此方法要注意的是在public double getDistance(point p)的方法中，传入的是point对象的值，所以在定义的时候直接定义了三个p;p2;or目的是方便调用 定义一个类并打印其姓名和年龄 编写 Java 程序,用于显示人的姓名和年龄。 定义一个人类Person。 该类中应该有两个私有属性： 姓名 (name) 和年龄 (age) 。 定义构造方法用来初始化数据成员。 再定义显示(display()) 方法将姓名和年龄打印出来。 在 main 方法中创建人类的实例然后将信息显示。 12345678910111213141516171819202122232425262728293031package 编码题1;/** * 编写 Java 程序,用于显示人的姓名和年龄。 * 定义一个人类Person。 * 该类中应该有两个私有属性： 姓名 (name) 和年龄 (age) 。 * 定义构造方法用来初始化数据成员。 * 再定义显示(display()) 方法将姓名和年龄打印出来。 * 在 main 方法中创建人类的实例然后将信息显示。 * @author pc-mac * */public class Person &#123; private String name; private int age; public static void main(String[] args) &#123; Person n1 = new Person("零分",20); n1.disPlay(); &#125; public Person(String name,int age) &#123; this.name = name; this.age = age; &#125; public void disPlay() &#123; System.out.println(name); System.out.println(age); &#125;&#125; 构造与重载定义个人信息 构造方法与重载： 定义一个网络用户类，信息有用户 ID、用户密码、 email 地址。 在建立类的实例时把以上三个信息都作为构造函数的参数输入。 其中用户 ID 和用户密码时必须缺省时，email地址是用户 ID 加上字符串”@qq.com”。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package 编码题3;/** * 构造方法与重载： * 定义一个网络用户类，信息有用户 ID、用户密码、 email 地址。 * 在建立类的实例时把以上三个信息都作为构造函数的参数输入。 * 其中用户 ID 和用户密码时必须缺省时，email地址是用户 ID 加上字符串"@qq.com"。 * @author pc-mac * */public class User &#123; public static void main(String[] args) &#123;// NetUser n1 = new NetUser(1001,"123654");//不能这么写 NetUser n1 = new NetUser(); n1.id = 1001; n1.pwd = "123456"; NetUser n2 = new NetUser(1003, "654321", "952339610@qq.com"); NetUser n3 = new NetUser(1002, "654789"); n1.disPlay(); n3.disPlay(); System.out.printf("用户为：%d的密码是:%s,邮箱是:%s\n",n2.id,n2.pwd,n2.email); &#125;&#125;class People&#123; int id; String pwd;&#125;class NetUser extends People&#123; String email; public NetUser(int id,String pwd) &#123; this.id = id; this.pwd = pwd; this.email = id + "@qq.com"; &#125; public NetUser(int id,String pwd,String email) &#123; this.id = id; this.pwd = pwd; this.email = email; &#125; public NetUser() &#123; &#125; public void disPlay() &#123; System.out.println("用户名:" + id + "密码是:" + "邮箱是:" + email); &#125;&#125; 进制转换 十进制转换 转换成二进制 转换成八进制 转换成十六进制 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package 编码题4;import java.util.Scanner;/** * 十进制转换 * 转换成二进制 * 转换成八进制 * 转换成十六进制 * @author pc-mac * */public class TestSwap &#123; public static void main(String[] args) &#123; System.out.println("请输入一个数进行转换:"); Scanner nScanner = new Scanner(System.in); Swap nSwap = new Swap(); int x = nScanner.nextInt(); nSwap.two(x); nSwap.eight(x); nSwap.tensix(x); &#125;&#125;class Swap&#123; int n; public void two(int n) &#123; this.n = n; int k = 1,sum = 0,y; while (n != 0) &#123; y = n % 2; n = n / 2; sum += y*k; k *= 10; &#125; System.out.println(sum); &#125; public void eight(int n) &#123; this.n = n; int k = 1,sum = 0,y; while (n != 0) &#123; y = n % 8; n = n / 8; sum += y*k; k *= 10; &#125; System.out.println(sum); &#125; public void tensix(int n) &#123; this.n = n; int i = 0,k; int[] a = new int[10]; char count[] = &#123;'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'&#125;; while(n != 0)&#123; a[i++] = n % 16; n = n / 16; &#125; for (int j = a.length-1 ; j &gt;= 0 ; j--) &#123; k = a[j]; System.out.printf("%c",count[k]); &#125; &#125;&#125; 随机生成月份 随机生成月份和字母并且判断是不是原因字母 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Switch &#123; public static void main(String[] arge) &#123; int month = (int)(1+12*Math.random()); System.out.println(month); switch (month) &#123; case 1: System.out.println("一月份"); break; case 2: System.out.println("二月份"); break; case 3: System.out.println("三月份"); break; case 4: System.out.println("四月份"); break; case 5: System.out.println("五月份"); break; case 6: System.out.println("六月份"); break; default: System.out.println("不是一二三四五六月份"); break; &#125; System.out.println("*************"); char a = 'a'; int rand = (int) (25*Math.random()); char a1 = (char) (a + rand); System.out.print(a1 + ":"); switch (a1) &#123; case 'a': case 'e': case 'i': case 'o': case 'u': System.out.println("这是元音字母！"); break; default: System.out.println("这不是元音字母！"); break; &#125; &#125;&#125; 数组的使用 创建一个类包括ID 和 Name 利用数组建立三个对象 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package 数组的使用;public class Arrary &#123; public static void main(String[] args) &#123; int[] arr1 = new int[10]; String[] arr2 = new String[10]; for (int i = 0; i &lt; arr1.length; i++) &#123;//在这里 arr1.length == 10 arr1[i] = 10*i; &#125; for (int i = 0; i &lt; arr1.length; i++) &#123; System.out.println(arr1[i]); &#125; User[] arr3 = new User[10]; arr3[0] = new User(1001, "零分"); arr3[1] = new User(1002, "满分"); arr3[2] = new User(1003, "没分"); for (int i = 0; i &lt; arr3.length; i++) &#123; System.out.println(arr3[i].getName()); &#125; &#125;&#125;class User&#123; public User(int id,String name) &#123; this.id = id; this.name = name; &#125; private int id; private String name; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; &#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>自学</tag>
        <tag>心得</tag>
        <tag>总结</tag>
        <tag>经验</tag>
        <tag>期末</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构期末总结]]></title>
    <url>%2F2019%2F02%2F10%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9C%9F%E6%9C%AB%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[数据结构重点分析及期末总结 零分(网络ID)是某师范大学，计科专业的一名屌丝，针对数据结构一科目的期末算法编程考试总结了如下几个算法。 重点分析 简单题型 栈 队列 树 排序 简单题型往下翻…………… 栈12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;iostream&gt;using namespace std;const int stackmax=100;//c初始值分配量typedef char st;typedef struct&#123; char *base; char *top; int stacksize;&#125;stack;int initstack(stack &amp;s)&#123;//初始化 s.base=new st[stackmax];//为顺序栈动态分配d一个最大容量为stachkmax的数组空间 if (!s.base) &#123; return 0;//储存分配空间失败 &#125; s.top=s.base;//top初始为base，空栈 s.stacksize=stackmax;//置为栈的最大容量 return 1;&#125;int putstack(stack &amp;s,char e)&#123;//入栈 if(s.top-s.base==s.stacksize)&#123;//当相等时为满栈 cout&lt;&lt;"满栈"&lt;&lt;endl; return 0; &#125; *s.top=e;//元素e压入栈顶 s.top++;//栈顶指针+1 return 1;&#125;char gettop(stack s)&#123; if(s.top!=s.base) cout&lt;&lt;*(s.top-1);//取q栈顶指针 return 0;&#125;int outstack(stack &amp;s,int e)&#123; if (s.top==s.base) &#123; return 0; &#125; e=*--s.top;//将d栈顶元素给e向下移一位 return 1;&#125;void disp(stack s)&#123; long int i; for(i=0;i&lt;s.top-s.base;i++)&#123; cout&lt;&lt;s.base[i]; &#125; cout&lt;&lt;endl;&#125;int main()&#123; char e; stack s; initstack(s); putstack(s,'A'); putstack(s,'B'); putstack(s,'C'); putstack(s,'D'); cout&lt;&lt;"栈S为："; disp(s); cout&lt;&lt;"栈顶元素为："; e=gettop(s); cout&lt;&lt;e&lt;&lt;endl; outstack(s,e); cout&lt;&lt;"栈顶出栈后的S："; disp(s); return 0;&#125; 队列12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include&lt;iostream&gt;using namespace std;const int MAXQSIZE=6;typedef char QElemType;typedef struct&#123; QElemType *base; int front ; int rear; &#125; SqQueue;int InitQueue(SqQueue &amp;Q)&#123; Q.base= new QElemType[MAXQSIZE]; if(!Q.base) return 0; Q.front =Q.rear=0; return 1;&#125;int EnQueue( SqQueue &amp;Q,QElemType e)&#123; if((Q.rear+1)%MAXQSIZE==Q.front)//队满 &#123; cout&lt;&lt;"错误"&lt;&lt;endl; &#125; Q.base[Q.rear] =e;//新元素插入队尾 Q.rear=(Q.rear+1)%MAXQSIZE;//队尾指针向后移动一位 return 1;&#125;int lengt(SqQueue &amp;Q)//求队长度&#123; return (Q.rear-Q.front+MAXQSIZE)%MAXQSIZE;&#125;int deleteQ(SqQueue &amp;Q,QElemType &amp;e)&#123; if(Q.rear==Q.front)//队空 return 0; e=Q.base[Q.front];//保存对头元素 Q.front=(Q.front+1)%MAXQSIZE;//队头指针向后移动一位 return 1;&#125;int DisQ(SqQueue Q)&#123; int m,i; m=lengt(Q); if(m==0) cout&lt;&lt;"空队列"; if((Q.rear+1)%MAXQSIZE==Q.front) cout&lt;&lt;"队满"&lt;&lt;endl; for(i=Q.front; i%MAXQSIZE!=Q.rear;i++) cout&lt;&lt;Q.base[i]; cout&lt;&lt;endl; return 0;&#125;int main()&#123; SqQueue Q; QElemType e; InitQueue(Q); DisQ(Q); EnQueue(Q,'A'); EnQueue(Q,'B'); EnQueue(Q,'C'); EnQueue(Q,'D'); cout&lt;&lt;"长度="; cout&lt;&lt;lengt(Q); cout&lt;&lt;"队列为="; DisQ(Q); deleteQ(Q,e); cout&lt;&lt;"长度="; cout&lt;&lt;lengt(Q); cout&lt;&lt;"队列为="; DisQ(Q); EnQueue(Q,'E'); cout&lt;&lt;"长度="; cout&lt;&lt;lengt(Q); cout&lt;&lt;"队列为="; DisQ(Q); EnQueue(Q,'F'); cout&lt;&lt;"队列为="; DisQ(Q); return 0;&#125; 树123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include &lt;stdlib.h&gt;#include &lt;iostream&gt;using namespace std;typedef int InfoType;typedef int KeyType; //假定关键字类型为整数typedef struct node //结点类型&#123; KeyType key; //关键字项 InfoType otherinfo; //其它数据域，InfoType视应用情况而定，下面不处理它 struct node *lchild,*rchild; //左右孩子指针&#125;BSTNode;typedef BSTNode *BSTree; //BSTree是二叉排序树的类型//在二叉排序树T上查找关键字为key的结点，成功时返回该结点位置，否则返回NULLBSTNode *findbst(BSTree t,KeyType key)&#123; if(t==NULL||key==t-&gt;key) return t; if(key&lt;t-&gt;key) return findbst(t-&gt;lchild,key); else return findbst(t-&gt;rchild,key);&#125;void InsertBST(BSTree *T,int key)&#123; //插入一个值为key的节点到二叉排序树中 BSTNode *p,*q; if((*T)==NULL) &#123; //树为空树 (*T)=(BSTree)malloc(sizeof(BSTNode)); (*T)-&gt;key=key; (*T)-&gt;lchild=(*T)-&gt;rchild=NULL; &#125; else &#123; p=(*T); while(p) &#123; q=p; if(p-&gt;key&gt;key) p=q-&gt;lchild; else if(p-&gt;key&lt;key) p=q-&gt;rchild; else &#123; cout&lt;&lt;endl&lt;&lt;"该二叉排序树中含有关键字为"&lt;&lt;key&lt;&lt;"的节点!"&lt;&lt;endl; return; &#125; &#125; p=(BSTree)malloc(sizeof(BSTNode)); p-&gt;key=key; p-&gt;lchild=p-&gt;rchild=NULL; if(q-&gt;key&gt;key) q-&gt;lchild=p; else q-&gt;rchild=p; &#125;&#125;BSTree CreateBST(void)&#123; //输入一个结点序列，建立一棵二叉排序树，将根结点指针返回 BSTree T=NULL; //初始时T为空树 KeyType key; cin&gt;&gt;key; //读入一个关键字 while(key) &#123; //假设key=0是输入结束标志 InsertBST(&amp;T,key); //将key插入二叉排序树T cin&gt;&gt;key; //读入下一关键字 &#125; return T; //返回建立的二叉排序树的根指针&#125;void ListBinTree(BSTree T) //用广义表示二叉树&#123; if(T!=NULL) &#123; cout&lt;&lt;T-&gt;key; if(T-&gt;lchild!=NULL||T-&gt;rchild!=NULL) &#123; cout&lt;&lt;"("; ListBinTree(T-&gt;lchild); if(T-&gt;rchild!=NULL) cout&lt;&lt;","; ListBinTree(T-&gt;rchild); cout&lt;&lt;")"; &#125; &#125;&#125;int main()&#123; BSTNode *findbst(BSTree t,KeyType key); void InsertBST(BSTree *Tptr,KeyType key); BSTree CreateBST(); void ListBinTree(BSTree T); BSTree T; BSTNode *p; int key; cout&lt;&lt;"请输入关键字（输入0为结束标志）："&lt;&lt;endl; T=CreateBST(); ListBinTree(T); cout&lt;&lt;endl; cout&lt;&lt;"请输入欲查找关键字:"; cin&gt;&gt;key; p=findbst(T,key); if(p==NULL) cout&lt;&lt;"没有找到"&lt;&lt;key&lt;&lt;"！"&lt;&lt;endl; else cout&lt;&lt;"找到"&lt;&lt;key&lt;&lt;"！"&lt;&lt;endl; ListBinTree(p); cout&lt;&lt;endl; return 0;&#125; 冒泡排序12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;stdio.h&gt;#define MaxSize 20typedef int KeyType; //定义关键字类型typedef char InfoType[10];typedef struct //记录类型&#123; KeyType key; //关键字项 InfoType data; //其他数据项,类型为InfoType&#125; RecType; //排序的记录类型定义void InsertSort(RecType R[],int n) //对R[0..n-1]按递增有序进行直接插入排序&#123; int i,j,k; RecType tmp; for (i=1; i&lt;n; i++) &#123; tmp=R[i]; j=i-1; //从右向左在有序区R[0..i-1]中找R[i]的插入位置 while (j&gt;=0 &amp;&amp; tmp.key&lt;R[j].key) &#123; R[j+1]=R[j]; //将关键字大于R[i].key的记录后移 j--; &#125; R[j+1]=tmp; //在j+1处插入R[i] printf("i=%d: ",i); for (k=0; k&lt;n; k++) printf("%d ",R[k].key); printf("\n"); &#125;&#125;int main()&#123; int i,n=5; RecType R[MaxSize]; KeyType a[]= &#123;3,24,12,6,1&#125;; for (i=0; i&lt;n; i++) R[i].key=a[i]; printf("排序前:"); for (i=0; i&lt;n; i++) printf("%d ",R[i].key); printf("\n"); InsertSort(R,n); printf("排序后:"); for (i=0; i&lt;n; i++) printf("%d ",R[i].key); printf("\n"); return 0;&#125; 题型分类 插入 删除 合并 排序 折半查找递归算法 顺序表题型插入12345678910int listinsert_sq(sqlist &amp;l,int i,et e)&#123; if(i&lt;1||i&gt;l.length+1) return 0; for (int j=l.length-1; j&gt;=i-1; j--) &#123; l.elem[j+1]=l.elem[j]; &#125; l.elem[i-1]=e; ++l.length; return 1;&#125; 删除12345678910int listdelete_sq(sqlist &amp;l,int i,et &amp;e)&#123; if(i&lt;1||i&gt;l.length) return 0; e=l.elem[i-1]; for (int j=i; j&lt;=l.length-1; j++) &#123; l.elem[j-1]=l.elem[j]; &#125; --l.length; return 1;&#125; 完整程序12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include"iostream"using namespace std;#define maxsize 100typedef char et;typedef struct&#123; et *elem; int length;&#125;sqlist;int initlist_sq(sqlist &amp;l)&#123; l.elem=new et[maxsize]; if(!l.elem) return 0; l.length=0; return 1;&#125;int listinsert_sq(sqlist &amp;l,int i,et e)&#123; if(i&lt;1||i&gt;l.length+1) return 0; for (int j=l.length-1; j&gt;=i-1; j--) &#123; l.elem[j+1]=l.elem[j]; &#125; l.elem[i-1]=e; ++l.length; return 1;&#125;int listdelete_sq(sqlist &amp;l,int i,et &amp;e)&#123; if(i&lt;1||i&gt;l.length) return 0; e=l.elem[i-1]; for (int j=i; j&lt;=l.length-1; j++) &#123; l.elem[j-1]=l.elem[j]; &#125; --l.length; return 1;&#125;void disp_sq(sqlist l)&#123; if(l.length==0) cout&lt;&lt;"此顺序表为空"&lt;&lt;endl; for(int i=0;i&lt;l.length;i++)&#123; cout&lt;&lt;l.elem[i]; &#125; cout&lt;&lt;endl;&#125;int main()&#123; et e; sqlist l; initlist_sq(l); disp_sq(l); listinsert_sq(l,1,'A'); listinsert_sq(l,2,'B'); listinsert_sq(l,3,'C'); disp_sq(l); listdelete_sq(l,1,e); disp_sq(l); cout&lt;&lt;"删除的元素是："&lt;&lt;e&lt;&lt;endl;&#125; 链表题型插入1234567891011121314151617int listinsert(lk &amp;l,int i,et e)&#123; lk p; p=l; int j=0; while(p&amp;&amp;j&lt;i-1)&#123; p=p-&gt;next; j++; &#125; if (!p||j&gt;i-1) &#123; return 0; &#125; lk s=new ln; s-&gt;date=e;//将e的值赋值给s的值域 s-&gt;next=p-&gt;next;//新元素s的指针域指向旧元素p的指针域 p-&gt;next=s;//将p的指针域指向s元素 return 1;&#125; 删除123456789101112131415161718int listdelete(lk &amp;l,int i,et &amp;e)&#123; lk p; p=l; int j=0; while(p-&gt;next&amp;&amp;j&lt;i-1)&#123; p=p-&gt;next; j++; &#125; if (!(p-&gt;next)||j&gt;i-1) &#123; return 0; &#125; lk q; q=p-&gt;next;//q的指针指向p的指针域 p-&gt;next=q-&gt;next;//p的指针域指向q的指针域 e=q-&gt;date;//将删除q的值域的值赋值给e的位置值 delete q; return 1;&#125; 求最大值123456789101112131415void mlist(lk l)&#123;//最大值 lk s=new ln; lk p=l-&gt;next; s-&gt;data=p-&gt;data; while(p)&#123; if(s-&gt;data&lt;=p-&gt;data)&#123; s-&gt;data=p-&gt;data; p=p-&gt;next; &#125; else&#123; p=p-&gt;next; &#125; &#125; cout&lt;&lt;"最大值为："&lt;&lt;s-&gt;data&lt;&lt;endl;&#125; 逆序输出123456789101112int rlist(lk &amp;l)&#123;//逆序 lk p=l-&gt;next; lk q; l-&gt;next=NULL; while(p)&#123; q=p-&gt;next; p-&gt;next=l-&gt;next; l-&gt;next=p; p=q; &#125; return 1;&#125; 合并12345678910111213141516171819void mergelist(lk &amp;la,lk &amp;lb,lk &amp;lc)&#123; lk pa=la-&gt;next; lk pb=lb-&gt;next; lk pc=lc=la; while(pa&amp;&amp;pb)&#123; if(pa-&gt;data&lt;pb-&gt;data)&#123; pc-&gt;next=pa; pc=pa; pa=pa-&gt;next; &#125; else&#123; pc-&gt;next=pb; pc=pb; pb=pb-&gt;next; &#125; &#125; pc-&gt;next=pa?pa:pb;&#125; 查找123456789101112131415161718192021int max(lk &amp;la)&#123; lk pa=la-&gt;next;//将pa指针指向la表的头结点 lk ps=la;//ps的初始值指向la的头结点 int i=1,k=0;//定义两个计数变量 ps-&gt;data=pa-&gt;data;//给ps的数据域赋初值 while(pa)&#123; if(pa-&gt;data&gt;=ps-&gt;data)&#123; ps-&gt;data=pa-&gt;data;//将ps的数据域指向pa的数据域 pa=pa-&gt;next;//向下移一位 k=i;//满足条件用k记录 i++;//循环计数+1 &#125; else&#123; pa=pa-&gt;next; i++;//循环计数+1 &#125; &#125; cout&lt;&lt;"最大元素是："&lt;&lt;ps-&gt;data&lt;&lt;endl; cout&lt;&lt;"位置是第"&lt;&lt;k&lt;&lt;"个元素"&lt;&lt;endl; return 1;&#125; 折半查找12345678910111213int xfind(lk st,keyt t, int low, int high)&#123; if(low&lt;=high)&#123; int mid=(low+high)/2; if(st.elem[mid].key==t) return mid; else if (st.elem[mid].key&lt;t) return (xfind(st, t, mid+1, high)); else return (xfind(st, t, low, mid-1)); &#125; else return 0;&#125; 完整程序(插入,删除,最大,合并,逆序)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212#include&lt;iostream&gt;using namespace std;typedef struct ln&#123; int data; struct ln *next;&#125;*lk;int initlist(lk &amp;l)&#123; l=new ln; l-&gt;next=NULL; return 1;&#125;int insertlist(lk &amp;l,int i,int e)&#123; lk p=l;//错写成p=l-&gt;next int j=0; while(p&amp;&amp;j&lt;i-1)&#123; p=p-&gt;next; j++; &#125; if(!p||j&gt;i-1)&#123; return 0; &#125; lk s=new ln; s-&gt;data=e; s-&gt;next=p-&gt;next; p-&gt;next=s; return 1;&#125;int deletelist(lk &amp;l,int i,int &amp;e)&#123; lk p=l;//错写成p=l-&gt;next int j=0; while(p&amp;&amp;j&lt;i-1)&#123; p=p-&gt;next; j++; &#125; if(!p||j&gt;i-1)&#123; return 0; &#125; lk q=p-&gt;next; p-&gt;next=q-&gt;next; e=q-&gt;data; delete q; return 1;&#125;int margeinlist(lk &amp;la,lk &amp;lb,lk &amp;lc)&#123;//合并 lk pa=la-&gt;next; lk pb=lb-&gt;next; lk pc=lc=la; while(pa&amp;&amp;pb)&#123; if(pa-&gt;data&lt;pb-&gt;data)&#123; pc-&gt;next=pa; pc=pa; pa=pa-&gt;next; &#125; else&#123; pc-&gt;next=pb; pc=pb; pb=pb-&gt;next; &#125; &#125; pc-&gt;next=pa?pa:pb; return 1;&#125;int rlist(lk &amp;l)&#123;//逆序 lk p=l-&gt;next; lk q; l-&gt;next=NULL; while(p)&#123; q=p-&gt;next; p-&gt;next=l-&gt;next; l-&gt;next=p; p=q; &#125; return 1;&#125;void mlist(lk l)&#123;//最大值 lk s=new ln; lk p=l-&gt;next; s-&gt;data=p-&gt;data; while(p)&#123; if(s-&gt;data&lt;=p-&gt;data)&#123; s-&gt;data=p-&gt;data; p=p-&gt;next; &#125; else&#123; p=p-&gt;next; &#125; &#125; cout&lt;&lt;"最大值为："&lt;&lt;s-&gt;data&lt;&lt;endl;&#125;void disp(lk &amp;l)&#123; lk p=l-&gt;next; if(!p)&#123; cout&lt;&lt;"空表"&lt;&lt;endl; &#125; while(p)&#123; cout&lt;&lt;p-&gt;data; p=p-&gt;next; &#125; cout&lt;&lt;endl;&#125;int main()&#123; lk la,lb,lc; int e; initlist(la); initlist(lb); insertlist(la, 1, 1); insertlist(la, 2, 5); insertlist(la, 3, 7); insertlist(la, 4, 9); insertlist(lb, 1, 2); insertlist(lb, 2, 3); insertlist(lb, 3, 6); cout&lt;&lt;"la的元素是："; disp(la); cout&lt;&lt;"lb的元素是："; disp(lb); deletelist(la, 2, e); cout&lt;&lt;"删除的元素是："&lt;&lt;e&lt;&lt;endl; margeinlist(la, lb, lc); cout&lt;&lt;"合并后的元素是："; disp(lc); rlist(lc); cout&lt;&lt;"反序输出元素顺序为："; disp(lc); mlist(lc);&#125;#include &lt;iostream&gt;using namespace std;typedef char et;typedef struct ln&#123; et date; struct ln *next;&#125;ln,*lk;int initlist(lk &amp;l)&#123; l=new ln; l-&gt;next=NULL; return 1;&#125;int listinsert(lk &amp;l,int i,et e)&#123; lk p; p=l; int j=0; while(p&amp;&amp;j&lt;i-1)&#123; p=p-&gt;next; j++; &#125; if (!p||j&gt;i-1) &#123; return 0; &#125; lk s=new ln; s-&gt;date=e;//将e的值赋值给s的值域 s-&gt;next=p-&gt;next;//新元素s的指针域指向旧元素p的指针域 p-&gt;next=s;//将p的指针域指向s元素 return 1;&#125;int listdelete(lk &amp;l,int i,et &amp;e)&#123; lk p; p=l; int j=0; while(p-&gt;next&amp;&amp;j&lt;i-1)&#123; p=p-&gt;next; j++; &#125; if (!(p-&gt;next)||j&gt;i-1) &#123; return 0; &#125; lk q; q=p-&gt;next;//q的指针指向p的指针域 p-&gt;next=q-&gt;next;//p的指针域指向q的指针域 e=q-&gt;date;//将删除q的值域的值赋值给e的位置值 delete q; return 1;&#125;void disp(lk l)&#123; lk p=l-&gt;next; if (!p) &#123; cout&lt;&lt;"此链表为空"&lt;&lt;endl; &#125; while (p) &#123; cout&lt;&lt;p-&gt;date; p=p-&gt;next; &#125; cout&lt;&lt;endl;&#125;int main()&#123; lk l; et e; initlist(l); disp(l); listinsert(l, 1, 'A'); listinsert(l, 2, 'B'); listinsert(l, 3, 'C'); disp(l); listdelete(l, 2, e); cout&lt;&lt;"删除的元素是："&lt;&lt;e&lt;&lt;endl; disp(l); return 0;&#125; 完整代码(查找)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt;using namespace std;typedef struct ln&#123; int data; struct ln *next;&#125;*lk;int inilist(lk &amp;l)&#123; l=new ln; l-&gt;next=NULL; return 1;&#125;int listinsert(lk &amp;l,int i,int e)&#123; lk p=l;//定义一个指针p指向l的头结点 int j=0;//位置的初始值 while (p&amp;&amp;j&lt;i-1) &#123; p=p-&gt;next;//当满足条件是p指向下一位 j++;//位置值加一 &#125; if (!p||j&gt;i-1) &#123; return 0; &#125; lk s=new ln;//建立一个节点s s-&gt;data=e;//s节点的数据域等于e的数值 s-&gt;next=p-&gt;next;//s的next域指向p的next域 p-&gt;next=s;//p的next域指向s节点 return 1;&#125;int max(lk &amp;la)&#123; lk pa=la-&gt;next;//将pa指针指向la表的头结点 lk ps=la;//ps的初始值指向la的头结点 int i=1,k=0;//定义两个计数变量 ps-&gt;data=pa-&gt;data;//给ps的数据域赋初值 while(pa)&#123; if(pa-&gt;data&gt;=ps-&gt;data)&#123; ps-&gt;data=pa-&gt;data;//将ps的数据域指向pa的数据域 pa=pa-&gt;next;//向下移一位 k=i;//满足条件用k记录 i++;//循环计数+1 &#125; else&#123; pa=pa-&gt;next; i++;//循环计数+1 &#125; &#125; cout&lt;&lt;"最大元素是："&lt;&lt;ps-&gt;data&lt;&lt;endl; cout&lt;&lt;"位置是第"&lt;&lt;k&lt;&lt;"个元素"&lt;&lt;endl; return 1;&#125;int main()&#123; lk la;//定义三个表 inilist(la);//对表la的初始化 listinsert(la, 1, 2);//向la表中插入数据 listinsert(la, 2, 3); listinsert(la, 3, 5); listinsert(la, 4, 7); listinsert(la, 5, 10); listinsert(la, 6, 9); listinsert(la, 7, 8); max(la);&#125; 完整代码(折半查找)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293//// main.cpp// 实验六数据结构//// Created by PC-MAC on 2018/12/3.// Copyright © 2018 PC-MAC. All rights reserved.//#include"iostream"using namespace std;const int tmax=10;typedef int keyt;typedef struct&#123; keyt key;&#125;elemtype;//每行内容typedef struct&#123; elemtype *elem; int length;&#125;lk;int find(lk st,keyt key)&#123; int i; st.elem[0].key=key; for(i=st.length;st.elem[i].key!=key;i--); return i;&#125;int twofind(lk st,keyt key)&#123; int low,high,mid; low=1; high=st.length; while(low&lt;=high)&#123; mid=(low+high)/2; if(st.elem[mid].key==key) return mid; else if(st.elem[mid].key&gt;key) high=mid-1; else low=mid+1; &#125; return 0;&#125;int xfind(lk st,keyt t, int low, int high)&#123; if(low&lt;=high)&#123; int mid=(low+high)/2; if(st.elem[mid].key==t) return mid; else if (st.elem[mid].key&lt;t) return (xfind(st, t, mid+1, high)); else return (xfind(st, t, low, mid-1)); &#125; else return 0;&#125;int main()&#123; keyt a[]=&#123;0,13,24,35,32,65,19,7,74,20,38&#125;; lk t; t.elem=new elemtype[tmax]; t.length=10; for(int i=1;i&lt;=10;i++)&#123; t.elem[i].key=a[i]; &#125; cout&lt;&lt;"查找到的元素位置为："&lt;&lt;find(t, 35)&lt;&lt;endl; lk s; s.elem=new elemtype[tmax]; s.length=10; keyt b[]=&#123;0,2,4,6,8,10,12,14,16,18,20&#125;; for(int k=1;k&lt;=10;k++)&#123; s.elem[k].key=b[k]; &#125; cout&lt;&lt;"折半查找到的元素位置为："&lt;&lt;twofind(s, 14)&lt;&lt;endl; int i, j; keyt arr[10]; for (i = 0; i &lt; 10; i++) &#123; arr[i] = i * 2; &#125; cout &lt;&lt; "输入查找数字:"; cin &gt;&gt; j; lk P; P.elem = new elemtype; P.length = 10; for (int j = 1; j &lt;= 10; j++) &#123; P.elem[j].key = arr[j]; &#125; cout&lt;&lt;"递归折半查找到的元素位置为："&lt;&lt;xfind(P, j, 0, 10)&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>经验</tag>
        <tag>期末</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[更换域名方法]]></title>
    <url>%2F2019%2F02%2F09%2F%E6%9B%B4%E6%8D%A2%E5%9F%9F%E5%90%8D%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Blog更换域名教程更换流程 1.更改域名解析； 2.更改站点配置文件URL； 3.改变CNAM中的域名； 4.改变robots.txt中，Sitemap字段； 5.查看Github中域名绑定是否更改； 6.对Google爬虫进行站点验证及添加； 更换域名解析在自己的域名控制台中导出自己之前绑定改过的域名，并在新的域名解析中添加。 更改站点配置文件URL进入站点配置文件，更改字段：url: https://xxx.com 改变CNAM中的域名打开你的blog目录，source/CNAME，直接添加即可。 CNAME会直接关联Github的域名绑定 改变robots打开你的blog目录，source/robots.txt中，改变Sitemap字段添加你的域名地址。 为了给爬虫robots做引导 在Github中域名绑定查看Github中域名绑定是否更改，具体位置在你的库文件下的域名绑定模块。 对Google爬虫进行站点验证及添加点击地址自行添加：https://www.google.com/webmasters/tools/home?hl=zh-CN]]></content>
      <categories>
        <category>域名</category>
        <category>教程</category>
      </categories>
      <tags>
        <tag>域名</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小米Pro15.6 安装黑苹果兼MacOS Mojave安装教程]]></title>
    <url>%2F2019%2F02%2F03%2F%E5%B0%8F%E7%B1%B3PRO%E5%AE%89%E8%A3%85%E9%BB%91%E8%8B%B9%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[小米Pro15.6 安装黑苹果兼MacOS Mojave安装教程写作/安装流程 1.下载镜像； 2.刻盘； 3.安装； 4.替换/完善EFI； Windows下制作macOS Mojave安装盘准备工具 U盘大于8G U 盘大小不限做 PE 盘 系统镜像下载：文章结尾 etcher 制作安装镜像 镜像制作 下载etcher 打开镜像 选择U盘 点击Flash即可 小米BIOS设置开机按F2进入BIOS设置 Security（1） 选择Set Supervisor Password，在Enter New Password这里输入密码，然后在Enter New Password Again这里重复输入密码，这一步是设置进入BIOS的密码。 Security（2） 再次进BIOS，依然在Security分类里选择Secure Boot Mode选项，将其设置为Disable，关闭安全模式。最后按F10，对你的刚才的设置进行保存并退出。 安装系统开机，按F12选择U盘引导 进入CLOVER主界面，直接回车，开始引导mac OS 很多的机友都是会在这个地方翻车。出现问题请私聊我反馈，请提供翻车照片及机器配置图。不提供任何信息直接发问就是耍流氓 这个过程需要1-2分钟,耐心等待，进入安装程序,出现语言选择界面 选择简体中文，点击继续 出现安装向导，点击继续 阅读许可协议，点击继续 点击同意，继续 出现安装界面，这里是让你选择安装磁盘 请点击菜单上面的实用工具-&gt;磁盘工具 出现磁盘工具，在磁盘工具里面所做的操作涉及到你的数据安全，请认真仔细确认后再操作，否则由此造成的一切后果本站概不承担。 点击窗口左上角的显示，选择显示所有设备 选择APPLE SSD macOS-0 SSD Media本例中为虚拟机中的磁盘名称，请根据你的设备选择相应的磁盘 点击抹掉， 假设您的磁盘是空的或者数据是已经备份过的,别怪我没提醒你!!! 在弹出的窗口中输入：名称：Mac；格式：Mac OS扩展(日志式)（10.13.X以上版本）APFS（10.14.X以上版本）；方案：GUID分区图，在点击抹掉按钮之前，请再次确认你的磁盘已经提前做了数据备份 点击抹除，然后等待操作结束 点击完成，通过菜单选择退出磁盘工具或者按窗口左上角红色按钮离开磁盘工具 返回到安装界面 选择Mac磁盘，点击继续 它会把USB安装盘上的安装文件预复制到要安装的系统分区里，这个过程通常会持续1-2分钟 重启后继续安装，在安装期间，通常会自动重启2-3遍 之所以有重启的动作是因为从Mac OS 10.13.x开始，苹果公司将默认的HFS磁盘分区强行换成APFS分区，它会在第二次重启之后做HFS-&gt;APFS转换的动作，转换成功后，继续安装过程。 重启重点第一次重启事实上Mac OS，已经完成的解压到了硬盘上，就跟Windows中拷贝U盘文件道理是一样的。 所以无论是第几次重启，哪怕是第一次，也可以直接进入Windows系统继续如下操作，因为这个时候Mac的基本配置文佳已经拷贝完成了。 合并或粘贴EFI脱离USB运行[Windows篇单硬盘版]基于最新版本的MacOS是不继承任何EFI 的，也就是说除了集成Clover，没有任何驱动的配置，所以若U盘中不替换EFI是无法正常启动桌面的，尽管配置成功，开机跑代码也会提示。所以这个时候就要借着重启的机会，提前合并粘贴EFI文件。 重启电脑正常开机进入Windows桌面，打开DG（DiskGenius分区工具）找到ESP分区，点击右侧的浏览文件 合并EFI打开ESP文件夹（这里要注意的是，现在有的文件夹，都是Windows的，一定不要直接删除，否则Win系统无法开机） 再次强调，若之前安装过Win系统，想要做双系统的朋友，只需要拷贝EFI文件中的CLOVER文件夹即可！剩下的都不需要动。用快捷键粘贴进去。 粘贴以后的样子，可能会多出一个APPLE文件夹，不需要搭理。 [Windows篇双硬盘版]重启电脑正常开机进入Windows桌面，打开DG（DiskGenius分区工具）找到ESP分区，点击右侧的浏览文件 这里我就不放图了，原理与单硬盘版相同，只不过是找到你安装Mac OS的那个硬盘 粘贴EFI直接将EFI文件夹里面的所有文件复制到ESP分区,这里给大家看一下我的，直接带着EFI粘贴进去就可以了里面的都不要管 添加启动项到BIOS[Windows篇单硬盘版]打开BOOTICE，看图操作，图上有序号 添加盘符 设置启动项添加盘符以后，添加启动项，并且改变启动项的顺序，若开机为Clover启动，请调执第一位。 [Windows篇双硬盘版]开机进BIOS设置启动项顺序，一般主板应该是boot选项卡中调节，调第一启动项为你的Mac OS分区。 继续执行Mac OS 的重启 重启重点这时候你可以拔掉U盘扔掉了。 本次重启是继续之前未完成的重启，进入你的Mac OS的安装的硬盘（这里Mac OS 的安装硬盘因为拔掉了U盘并且替换好EFI应该就只有一个了），继续安装系统时的重启过程 第二阶段重启第二阶段的安装会有两种界面,一种是不进安装界面直接安装,另一种是先进入安装界面直接安装,需要注意的是,无论是哪一种界面下,安装的过程中全程是禁用鼠标和键盘的,需要你做的只是耐心等待它安装完成 设置向导选择国家：中国 设置键盘 你可以添加自己熟悉的输入法，然后点击继续，出现数据与隐私，阅读后点击继续 选择不传输任何信息，点击继续 点击稍后设置 出现您确定要中法使用Apple ID来登录吗？，点击跳过 出现条款与条件，点击同意 出现我已经阅读并同意&quot;macOS软件许可协议&quot;，点击同意 出现创建电脑用户的窗口,输入用户名和密码,点击继续 创建电脑用户用户自己编辑 系统会创建初始用户，接着进行快捷设置 弹出界面，让你选择外观，您可以根据个人的喜好选择浅色主题或者深色主题，点击继续 出现正在设置您的Mac,请稍候完成设置向导 设置向导完成，根据选择主题的不同，分别进入不同的界面 进入桌面 出现桌面后,整个的安装向导就完成了。 安装后的系统设置如果没有什么问题，看到开机页面了，那么聪明的你说明你的黑苹果系统已经安装成功了。 快捷键的小修改很多人习惯了Windows，所以这里的快捷键做一下调整，如下修改就可以了 下载链接MacOS：链接: https://pan.baidu.com/s/1z96tO0D0cZu0EU5McNG09A 提取码: iusp 12.28EFI：链接: https://pan.baidu.com/s/1t2dHHV0uFYRSVe-IA4wRBQ 提取码: n4ff 鸣谢与支持Mac OS、EFI文件及部分文章图片转载于黑果小兵的部落阁 文章如又不懂的地方，可以添加我的微信，或者QQ，952339610，即可在线咨询！]]></content>
      <categories>
        <category>黑苹果</category>
        <category>教程</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>黑苹果</tag>
        <tag>小米</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub-Hexo-搭建个人网站详细教程]]></title>
    <url>%2F2019%2F01%2F29%2FGitHub-Hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[什么是Hexo ? Hexo是一款基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub和Heroku上，是搭建博客的首选框架。这里我们选用的是GitHub，你没看错，全球最大的同性恋交友网站（逃……）。Hexo同时也是GitHub上的开源项目，参见：hexojs/hexo 如果想要更加全面的了解Hexo，可以到其官网 Hexo 了解更多的细节，因为Hexo的创建者是台湾人，对中文的支持很友好，可以选择中文进行查看。这里，默认各位猿/媛儿都知道GitHub就不再赘述。 这是我的个人博客效果: TheMrxk· Blog 下面正式从零开始搭建年轻人的第一个网站。 搭建步骤： 获得个人网站域名 GitHub创建个人仓库 安装Git 安装Node.js 安装Hexo 推送网站 绑定域名 常用的Hexo 命令 更换主题 个性化设置 添加播放器 发布文章 获得个人网站域名域名是网站的入口，也是网站的第一印象，比如饿了么的官网的域名是：https://www.ele.me/ ，很是巧妙。常见的有com,cn,net,org等后缀，也有小众的xyz,me,io等后缀，根据你自己的喜好，选择不同的后缀，比如我选择就是常见的com后缀。很多小众奇特的后缀在大陆是没办法备案的，网站也就无法上线。然而使用GitHub托管我们的网站，完全不需要备案，因为托管我们的网站内容的服务器在美国，而且在国内备案流程也比较繁杂，时间需要一周左右。 申请域名的地方有很多，这里推荐阿里云：阿里云-为了无法计算的价值 申请入口：域名注册 购买域名这也是我们整个搭建过程中惟一一个需要花钱的地方。如果你已经有了空闲域名就无需购买，直接使用即可。 GitHub创建个人仓库登录到GitHub,如果没有GitHub帐号，使用你的邮箱注册GitHub帐号：Build software better, together 点击GitHub中的New repository创建新仓库，仓库名应该为：用户名.http://github.io 这个用户名使用你的GitHub帐号名称代替，这是固定写法，比如我的仓库名为： 安装Git什么是Git ?简单来说Git是开源的分布式版本控制系统，用于敏捷高效地处理项目。我们网站在本地搭建好了，需要使用Git同步到GitHub上。从Git官网下载：Git - Downloading Package 现在的机子基本都是64位的，选择64位的安装包，下载后安装。 在命令行里输入git测试是否安装成功。 首先查看电脑是否安装的Git，终端输入： 1git 安装过则会输出：即表示成功安装 若安装失败，参看其他详细的Git安装教程。 Mac终端为例直接输入： 1brew install git 安装成功后，将你的Git与GitHub帐号绑定， 创建ssh key，配置git1，设置用户名和电子邮件（Github上每次提交都会记录他们） 12git config --global user.name &quot;你的GitHub用户名&quot;git config --global user.email &quot;你的GitHub邮箱&quot; 2，通过终端命令创建ssh密钥 1ssh-keygen -t rsa -C &quot;你的GitHub邮箱&quot; `952339610@qq.com`是我的邮件名，回车会有以下输出 1234567Last login: Sat Jan 6 14:12:16 on ttys000WMBdeMacBook-Pro:~ *******$ ssh-keygen -t rsa -C "952339610@qq.com"Generating public/private rsa key pair.Enter file in which to save the key (/Users/*******/.ssh/id_rsa): /Users/*******/.ssh/id_rsa already exists.Overwrite (y/n)? nWMBdeMacBook-Pro:~ *******$ 由于这里我原来已经创建过，这里我选n，没有创建过的，会要求确认路径和输入密码，我们这使用默认的一路回车就行。成功的话会在〜/下生成.ssh文件夹，进去，打开id_rsa.pub，复制里面的关键。 终端查看.ssh/id_rsa.pub文件 1open .ssh/id_rsa.pub 回车后，就会新弹出一个终端，然后复制里面的关键字段。 3，打开GitHub_Settings_keys 页面，新建new SSH Key Title：随便写 Key：粘贴刚刚复制的关键字 最后点击Add SSH key。 在Git Bash中检测GitHub公钥设置是否成功。 输入 ： 1ssh git@github.com 如上则说明成功。这里之所以设置GitHub密钥原因是，通过非对称加密的公钥与私钥来完成加密，公钥放置在GitHub上，私钥放置在自己的电脑里。GitHub要求每次推送代码都是合法用户，所以每次推送都需要输入账号密码验证推送用户是否是合法用户，为了省去每次输入密码的步骤，采用了ssh，当你推送的时候，git就会匹配你的私钥跟GitHub上面的公钥是否是配对的，若是匹配就认为你是合法用户，则允许推送。这样可以保证每次的推送都是正确合法的。 安装Node.jsHexo基于Node.js，Node.js下载地址：Download | Node.js 下载安装包，注意安装Node.js会包含环境变量及npm的安装，安装后。 检测Node.js是否安装成功，在终端中输入 1node -v 检测npm是否安装成功，在终端中输入 1npm -v 到这了，安装Hexo的环境已经全部搭建完成。 安装Hexo1.终端下使用npm命令安装Hexo，输入 1npm install -g hexo-cli 这个安装时间较长耐心等待，安装完成后。注：这个时候可能会报错，没有关系正常现象。 2.安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。初始化我们的博客路径为默认路径，输入（folder为文件名） 123hexo init &lt;folder&gt;cd &lt;folder&gt;npm install 注意，这里的命令都是作用在刚刚创建的文件夹中。 为了检测我们的网站雏形，分别按顺序输入以下三条命令： 1hexo g &amp;&amp; hexo s 过了漫长的等待如果http://localhost:4000/成功打开，那么就说明博客基本建立完成。 推送站点上面只是在本地预览，接下来要做的就是就是推送网站，也就是发布网站，让我们的网站可以被更多的人访问。在设置之前，需要解释一个概念，在blog根目录里的_config.yml文件称为站点配置文件，如下图 进入根目录里的themes文件夹，里面也有个_config.yml文件，这个称为主题配置文件，如下图 下一步将我们的Hexo与GitHub关联起来，打开站点的配置文件_config.yml，翻到最后修改为： 1234deploy: type: gitrepo: 这里填入你之前在GitHub上创建仓库的完整路径，记得加上 .gitbranch: master 参考如下： 保存站点配置文件。 其实就是给hexo d 这个命令做相应的配置，让hexo知道你要把blog部署在哪个位置，很显然，我们部署在我们GitHub的仓库里。最后安装Git部署插件，输入命令： 1npm install hexo-deployer-git --save 这时，我们分别输入命令： 1hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 完成后，打开浏览器，在地址栏输入你的放置个人网站的仓库路径，即 http://xxxx.github.io (比如我的xxxx就是我的GitHub用户名： 1TheMrxk.github.io 你就会发现你的博客已经上线了，可以在网络上被访问了。 绑定域名虽然在Internet上可以访问我们的网站，但是网址是GitHub提供的:http://xxxx.github.io ，而我们想使用我们自己的个性化域名，这就需要绑定我们自己的域名。这里演示的是在阿里云的域名绑定，在国内主流的域名代理厂商也就阿里云和腾讯云。登录到阿里云，进入管理控制台的域名列表，找到你的个性化域名，进入解析 第一步，包括添加三条解析记录，192.30.252.153是GitHub的地址，你也可以ping你的 http://xxxx.github.io 的ip地址，填入进去。第三个记录类型是CNAME，CNAME的记录值是：你的用户名.http://github.io 这里千万别弄错了。 第二步，登录GitHub，进入之前创建的仓库，点击settings，设置Custom domain，输入你的域名点击save保存。 第三步，进入本地博客文件夹 ，进入blog/source目录下，创建一个记事本文件，输入你的域名，对，只要写进你自己的域名即可。如果带有www，那么以后访问的时候必须带有www完整的域名才可以访问，但如果不带有www，以后访问的时候带不带www都可以访问。所以建议，不要带有www。这里我还是写了www(不建议带有www): 保存，命名为CNAME ，注意保存成所有文件而不是txt文件。 完成这三步，进入blog目录中，按住shift键右击打开命令行，依次输入： 1hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 这时候打开浏览器在地址栏输入你的个性化域名将会直接进入你自己搭建的网站。 配置站点常用的Hexo 命令123npm install hexo -g #安装Hexonpm update hexo -g #升级 hexo init #初始化博客 12345678命令简写hexo n &quot;我的博客&quot; == hexo new &quot;我的博客&quot; #新建文章hexo g == hexo generate #生成hexo s == hexo server #启动服务预览hexo d == hexo deploy #部署综合hexo clean &amp;&amp; hexo g &amp;&amp; hexo s #清除缓存生成及预览hexo clean &amp;&amp; hexo g -d #清除缓存生成及上传 12345hexo server #Hexo会监视文件变动并自动更新，无须重启服务器hexo server -s #静态模式hexo server -p 5000 #更改端口hexo server -i 192.168.1.1 #自定义 IPhexo clean #清除缓存，若是网页正常情况下可以忽略这条命令 更换主题先下载好你喜欢的主题，例如我的NexT，将站点主题拖动到themes的文件夹中，在站点配置文件中, 将theme字段改为next 1theme: next 个性化设置参考文献： 梯子客户端收录 hexo的next主题个性化配置教程 添加播放器打开网页版的网易云音乐，选择喜欢的音乐，点击生成外链播放器 复制外链的代码 在侧栏插入这首歌的音乐播放器，修改 blog\themes\next\layout_macro的sidebar.swig文件，添加刚刚复制的外链代码 重新生成、部署网页，效果如下 写作方法发布文章我们开始正式发布上线博客文章，在命令行中输入： 1hexo n "博客名字" 我们会发现在blog根目录下的source文件夹中的_post文件夹中多了一个 博客名字.md 文件，使用Markdown编辑器打开，就可以开始你的个人博客之旅了，Markdown常用的样式也就十来种，完全能够满足一般博文的样式要求，Mac推荐Typora。 给博客插入图片 1.首先把blog（hexo）目录下的_config.yml里的 1psot_asset_folder:设置为true 2.在blog（hexo）目录下执行: 1npm install hexo-asset-image --save 3.在blog（hexo）目录下Git Bash Here，运行hexo n “博客名”来生成md博客时，会在_post目录下看到一个与博客同名的文件夹。 4.将想要上传的图片先扔到文件夹下，然后在博客中使用markdown的格式引入图片： 1![你想要输入的替代文字](xxxx/图片名.jpg) ps：因为博客名和文件夹名字相同，所以不需要绝对路径，只要xxxx是文件夹的名字就可以了。]]></content>
      <categories>
        <category>web前端</category>
        <category>个人博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Test Title]]></title>
    <url>%2F2019%2F01%2F23%2Ftest-title%2F</url>
    <content type="text"><![CDATA[Welcome to TheMrxk Blog1$ This Is My First Blog! Test a sentence1$ Hellow Word~ Thank you everyonePs:如果你手速足够快的快，估计你是第一个看我博客的人，17点之前私聊我微信，过来领2块钱红包！🧧 More info：By TheMrxk 小开哥]]></content>
      <categories>
        <category>web前端</category>
        <category>测试</category>
      </categories>
      <tags>
        <tag>Hello</tag>
        <tag>新建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F10%2F28%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
